# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2022, Tigase, Inc
# This file is distributed under the same license as the TigaseDoc package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TigaseDoc \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-13 12:04-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../Tigase_Development/Component_Implementation.rst:2
msgid "Component Development"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:4
msgid ""
"A component in the Tigase is an entity with its own JID address. It can "
"receive packets, process them, and can also generate packets."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:6
msgid ""
"An example of the best known components is MUC or PubSub. In Tigase "
"however, almost everything is actually a component: Session Manager, s2s "
"connections manager, Message Router, etc…​ Components are loaded based on"
" the server configuration, new components can be loaded and activated at "
"run-time. You can easily replace a component implementation and the only "
"change to make is a class name in the configuration entry."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:8
msgid ""
"Creating components for Tigase server is an essential part of the server "
"development hence there is a lot of useful API and ready to use code "
"available. This guide should help you to get familiar with the API and "
"how to quickly and efficiently create your own component implementations."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:10
msgid "`Component implementation - Lesson 1 - Basics <#cil1>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:12
msgid "`Component implementation - Lesson 2 - Configuration <#cil2>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:14
msgid "`Component implementation - Lesson 3 - Multi-Threading <#cil3>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:16
msgid "`Component implementation - Lesson 4 - Service Discovery <#cil4>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:18
msgid "`Component implementation - Lesson 5 - Statistics <#cil5>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:20
msgid "`Component implementation - Lesson 6 - Scripting Support <#cil6>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:22
msgid "`Component implementation - Lesson 7 - Data Repository <#cil7>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:24
msgid "`Component implementation - Lesson 8 - Startup Time <#cil8>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:26
msgid "`Packet Filtering in Component <#packetfiltering>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst
msgid "_ cil1"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:31
msgid "Component Implementation - Lesson 1 - Basics"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:33
msgid ""
"Creating a Tigase component is actually very simple and with broad API "
"available you can create a powerful component with just a few lines of "
"code. You can find detailed API description elsewhere. This series "
"presents hands on lessons with code examples, teaching how to get desired"
" results in the simplest possible code using existing Tigase API."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:35
msgid ""
"Even though all Tigase components are just implementations of the "
"**ServerComponent** interface I will keep such a low level information to"
" necessary minimum. Creating a new component based on just interfaces, "
"while very possible, is not very effective. This guide intends to teach "
"you how to make use of what is already there, ready to use with a minimal"
" coding effort."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:37
msgid ""
"This is just the first lesson of the series where I cover basics of the "
"component implementation."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:39
msgid "Let’s get started and create the Tigase component:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:69
msgid ""
"As you can see we have 3 mandatory methods when we extends "
"**AbstractKernelBasedComponent**:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:71
msgid ""
"**String getComponentVersion()** which returns version of a component for"
" logging purposes"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:73
msgid ""
"**boolean isDiscoNonAdmin()** which decides if component will be visible "
"for users other that server administrators"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:75
msgid ""
"**void registerModules(Kernel kernel)** which allows you to register "
"component modules responsible for actual processing of packets"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:79
msgid ""
"If you decide you do not want to use modules for processing packets (even"
" though we strongly suggest to use them, as thanks to modules components "
"are easily extendible) you can implement one more method **void "
"processPacket(Packet packet)** which will be called for every packet sent"
" to a component. This method is actually logical as the main task for "
"your component is processing packets."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:81
msgid ""
"Class name for our new component is **TestComponent** and we have also "
"initialized a separated logger for this class. Doing This is very useful "
"as it allows us to easily find log entries created by our class."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:83
msgid ""
"With these a few lines of code you have a fully functional Tigase "
"component which can be loaded to the Tigase server; it can receive and "
"process packets, shows as an element on service discovery list (for "
"administrators only), responds to administrator ad-hoc commands, supports"
" scripting, generates statistics, can be deployed as an external "
"component, and a few other things."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:85
msgid ""
"Next important step is to create modules responsible for processing "
"packets. For now let’s create module responsible for handling messages by"
" appending them to log file:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:107
msgid ""
"Instance of ``Criteria`` class returned by ``Criteria "
"getModuleCriteria()`` is used by component class to decide if packet "
"should be processed by this module or not. In this case we returned "
"instance which matches any packet which is a **message**."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:109
msgid ""
"And finally we have a very important method ``void process(Packet "
"packet)`` which is main processing method of a component. If component "
"will receive packet that matches criteria returned by module - this "
"method will be called."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:111
msgid ""
"But how we can send packet from a module? **AbstractModule** contains "
"method **void write(Packet packet)** which you can use to send packets "
"from a component."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:113
msgid ""
"Before we go any further with the implementation let’s configure the "
"component in Tigase server so it is loaded next time the server starts. "
"Assuming our **init.tdsl** file looks like this one:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:129
msgid ""
"We can see that it already is configured to load two other components: "
"**MUC** and **PubSub**. Let’s add a third - our new component to the "
"configuration file by appending the following line in the properties "
"file:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:135
msgid "Now we have to restart the server."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:137
msgid ""
"There are a few ways to check whether our component has been loaded to "
"the server. Probably the easiest is to connect to the server from an "
"administrator account and look at the service discovery list."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:139
msgid "|service disco test comp admin 300|"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:178
msgid "service disco test comp admin 300"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:141
msgid ""
"If everything goes well you should see an entry on the list similar to "
"the highlighted one on the screenshot. The component description is "
"\"*Undefined description*\" which is a default description and we can "
"change it later on, the component default JID is: "
"**test@devel.tigase.org**, where **devel.tigase.org** is the server "
"domain and test is the component name."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:143
msgid ""
"Another way to find out if the component has been loaded is by looking at"
" the log files. Getting yourself familiar with Tigase log files will be "
"very useful thing if you plan on developing Tigase components. So let’s "
"look at the log file **logs/tigase.log.0**, if the component has been "
"loaded you should find following lines in the log:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:151
msgid ""
"If your component did not load you should first check configuration "
"files. Maybe the Tigase could not find your class at startup time. Make "
"sure your class is in **CLASSPATH** or copy a JAR file with your class to"
" Tigase **jars/** directory."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:153
msgid ""
"Assuming everything went well and your component is loaded by the sever "
"and it shows on the service discovery list as on the screenshot above you"
" can double click on it to get a window with a list of ad-hoc commands - "
"administrator scripts. A window on the screenshot shows only two basic "
"commands for adding and removing script which is a good start."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:155
msgid "|commands list test 200|"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:179
msgid "commands list test 200"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:157
msgid ""
"Moreover, you can browse the server statistics in the service discovery "
"window to find your new test component on the list. If you click on the "
"component it shows you a window with component statistics, very basic "
"packets counters."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:159
msgid "|service disco stats 200|"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:180
msgid "service disco stats 200"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:161
msgid ""
"As we can see with just a few lines of code our new component is quite "
"mighty and can do a lot of things without much effort from the developer "
"side."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:163
msgid ""
"Now, the time has come to the most important question. Can our new "
"component do something useful, that is can it receive and process XMPP "
"packets?"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:165
msgid ""
"Let’s try it out. Using you favorite client send a message to JID: "
"**test@devel.tigase.org** (assuming your server is configured for "
"**devel.tigase.org** domain). You can either use kind of XML console in "
"your client or just send a plain message to the component JID. According "
"to our code in **process(…​)** method it should log our message. For this"
" test I have sent a message with subject: \"*test message*\" and body: "
"\"*this is a test*\". The log file should contain following entry:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:176
msgid ""
"If this is a case we can be sure that everything works as expected and "
"all we now have to do is to fill the **process(…​)** method with some "
"useful code."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:182
msgid ": _cil2:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:185
msgid "Component Implementation - Lesson 2 - Configuration"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:187
msgid ""
"It might be hard to tell what the first important thing you should do "
"with your new component implementation. Different developers may have a "
"different view on this. It seems to me however that it is always a good "
"idea to give to your component a way to configure it and provide some "
"runtime settings."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:189
msgid "This guide describes how to add configuration handling to your component."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:191
msgid ""
"To demonstrate how to implement component configuration let’s say we want"
" to configure which types of packets will be logged by the component. "
"There are three possible packet types: **message**, **presence** and "
"**iq** and we want to be able to configure logging of any combination of "
"the three. Furthermore we also want to be able to configure the text "
"which is prepended to the logged message and to optionally switch secure "
"login. (Secure logging replaces all packet CData with text: *CData size: "
"NN* to protect user privacy.)"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:193
msgid ""
"Let’s create the following private variables in our component "
"**TestModule**:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:201
msgid ""
"To make them configurable we have to annote them with ``@ConfigField`` "
"annotation. It requires ``desc`` field (describing configuration option) "
"and has following optional properties: \\* ``alias`` - alternative name "
"of the variable \\* ``allowAliasFromParent`` - specifies whether value "
"from alias from parent bean should be allowed \\* ``type`` - specifies "
"general type of the field, which impacts possible obfuscation of the "
"value in the logs/\"config-dump\" file; possible values: ``Plain`` (no "
"changes), ``Password`` (complete value will be obfuscated) and "
"``JdbcUrl`` (only password part will be obfuscated from the URL)"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:212
msgid ""
"And this is it. Tigase Kernel will take care of this fields and will "
"update them when configuration will change."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:214
msgid ""
"The syntax in ``config.tdsl`` file is very simple and is described in "
"details in the *Admin Guide*. To set the configuration for your component"
" in ``config.tdsl`` file you have to append following lines to the file "
"inside test component configuration block:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:224
msgid ""
"The square brackets are used to mark that we set a list consisting of a "
"few elements, have a look at the *Admin Guide* documentation for more "
"details."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:226
msgid ""
"And this is the complete code of the new component module with a modified"
" ``process(…​)`` method taking advantage of configuration settings:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:264
msgid ""
"Of course we can do much more useful packet processing in the "
"``process(…​)`` method. This is just an example code."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:268
msgid ""
"Here we used a setter **setPacketType(String[] packetTypes)** which is a "
"setter for field **packetTypes**. Tigase Kernel will use it instead of "
"assigning value directly to a field which gives up opportunity to convert"
" value to different type and update other field - in our case we updated "
"**CRITERIA** field which will result in change of packet types which for "
"which method **void process(…​)** will be called."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst
msgid "_ cil3"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:273
msgid "Component Implementation - Lesson 3 - Multi-Threading"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:275
msgid ""
"Multi core and multi CPU machines are very common nowadays. Your new "
"custom component however, processes all packets in a single thread."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:277
msgid ""
"This is especially important if the packet processing is CPU expensive "
"like, for example, SPAM checking. In such a case you could experience "
"single Core/CPU usage at 100% while other Cores/CPUs are idling. Ideally,"
" you want your component to use all available CPUs."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:279
msgid ""
"Tigase API offers a very simple way to execute component’s "
"``processPacket(Packet packet)`` method in multiple threads. Methods "
"``int processingOutThreads()`` and ``int processingInThreads()`` returns "
"number of threads assigned to the component. By default it returns just "
"'1' as not all component implementations are prepared to process packets "
"concurrently. By overwriting the method you can return any value you "
"think is appropriate for the implementation. Please note, there are two "
"methods, one is for a number of threads for incoming packets to the "
"component and another for outgoing packets from the component. It used to"
" be a single method but different components have different needs and the"
" best performance can be achieved when the outgoing queues have a "
"separate threads pool from incoming queues. Also some components only "
"receive packets while other only send, therefore assigning an equal "
"number of threads for both that could be a waste of resources."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:283
msgid ""
"Due to how Kernel works you MUST avoid using variables in those methods. "
"If you would like to have this configurable at startup time you could "
"simply set ``processing-in-threads`` and ``processing-out-threads`` in "
"your component’s bean configuration."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:285
msgid ""
"If the packet processing is CPU bound only, you normally want to have as "
"many threads as there are CPUs available:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:298
msgid ""
"If the processing is I/O bound (network or database) you probably want to"
" have more threads to process requests. It is hard to guess the ideal "
"number of threads right on the first try. Instead you should run a few "
"tests to see how many threads is best for implementation of the "
"component."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:300
msgid ""
"Now you have many threads for processing your packets, but there is one "
"slight problem with this. In many cases packet order is essential. If our"
" ``processPacket(…​)`` method is executed concurrently by a few threads "
"it is quite possible that a message sent to user can takeover the message"
" sent earlier. Especially if the first message was large and the second "
"was small. We can prevent this by adjusting the method responsible for "
"packet distribution among threads."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:302
msgid "The algorithm for packets distribution among threads is very simple:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:308
msgid ""
"So the key here is using the ``hashCodeForPacket(…​)`` method. By "
"overwriting it we can make sure that all packets addressed to the same "
"user will always be processed by the same thread:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:329
msgid ""
"The above two methods give control over the number of threads assigned to"
" the packets processing in your component and to the packet distribution "
"among threads. This is not all Tigase API has to offer in terms of multi-"
"threading."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:331
msgid ""
"Sometimes you want to perform some periodic actions. You can of course "
"create Timer instance and load it with TimerTasks. As there might be a "
"need for this, every level of the Class hierarchy could end-up with "
"multiple Timer (threads in fact) objects doing similar job and using "
"resources. There are a few methods which allow you to reuse common Timer "
"object to perform all sorts of actions."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:333
msgid ""
"First, you have three methods allowing your to perform some periodic "
"actions:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:341
msgid ""
"An example implementation for periodic notifications sent to some address"
" could look like this one:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:357
msgid ""
"This method sends every **notificationFrequency** minute a message to "
"**abuseAddress** reporting how many spam messages have been detected "
"during last period. Please note, you have to call ``super.everyMinute()``"
" to make sure other actions are executed as well and you have to also "
"remember to keep processing in this method to minimum, especially if you "
"overwrite ``everySecond()`` method."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:359
msgid ""
"There is also a method which allow you to schedule tasks executed at "
"certain time, it is very similar to the ``java.util.Timer`` API. The only"
" difference is that we are using **ScheduledExecutorService** as a "
"backend which is being reused among all levels of Class hierarchy. There "
"is a separate ``ScheduledExecutorService`` for each Class instance "
"though, to avoid interferences between separate components:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:365
msgid ""
"Here is a code of an example component and module which uses all the API "
"discussed in this article:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:367
#: ../../Tigase_Development/Component_Implementation.rst:620
#: ../../Tigase_Development/Component_Implementation.rst:830
#: ../../Tigase_Development/Component_Implementation.rst:1117
msgid "**Example component code.**"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:429
#: ../../Tigase_Development/Component_Implementation.rst:693
#: ../../Tigase_Development/Component_Implementation.rst:912
#: ../../Tigase_Development/Component_Implementation.rst:1209
msgid "**Example module code.**"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst
msgid "_ cil4"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:514
msgid "Component Implementation - Lesson 4 - Service Discovery"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:516
msgid ""
"You component still shows in the service discovery list as an element "
"with \"*Undefined description*\". It also doesn’t provide any interesting"
" features or sub-nodes."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:518
msgid ""
"In this article I will show how to, in a simple way, change the basic "
"component information presented on the service discovery list and how to "
"add some service disco features. As a bit more advanced feature the guide"
" will teach you about adding/removing service discovery nodes at run-time"
" and about updating existing elements."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:520
msgid ""
"In order for the component to properly respond to ``disco#info`` and "
"``disco#items`` request you should register ``DiscoveryModule`` in your "
"component:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:529
msgid ""
"NOTE It’s essential to **explicitly** register ``DiscoveryModule`` in "
"your component."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:531
msgid ""
"Component description and category type can be changed by overriding two "
"following methods:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:545
msgid ""
"Please note, there is no such **'spam'** category type defined in the "
"`Service Discovery Identities registry <http://xmpp.org/registrar/disco-"
"categories.html>`__. It has been used here as a demonstration only. "
"Please refer to the Service Discovery Identities registry document for a "
"list of categories and types and pick the one most suitable for you."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:547
msgid ""
"After you have added the two above methods and restarted the server with "
"updated code, have a look at the service discovery window. You should see"
" something like on the screenshot."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:549
msgid "|spam filtering disco small|"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:788
msgid "spam filtering disco small"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:551
msgid ""
"Now let’s add method which will allow our module ``TestModule`` to return"
" supported features. This way our component will automatically report "
"features supported by all it’s modules. To do so we need to implement a "
"method **String[] getFeatures()** which returns array of ``String`` "
"items. This items are used to generate a list of features supported by "
"component."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:553
msgid ""
"Although this was easy, this particular change doesn’t affect anything "
"apart from just a visual appearance. Let’s get then to more advanced and "
"more useful changes."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:555
msgid ""
"One of the limitations of methods above is that you can not update or "
"change component information at run-time with these methods. They are "
"called only once during initialization of a component when component "
"service discovery information is created and prepared for later use. "
"Sometimes, however it is useful to be able to change the service "
"discovery during run-time."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:557
msgid ""
"In our simple spam filtering component let’s show how many messages have "
"been checked out as part of the service discovery description string. "
"Every time we receive a message we can to call:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:563
msgid ""
"*A small performance note, in some cases calling "
"``updateServiceDiscoveryItem(…​)`` might be an expensive operation so "
"probably a better idea would be to call the method not every time we "
"receive a message but maybe every 100 times or so.*"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:565
msgid ""
"The first parameter is the component JID presented on the service "
"discovery list. However, Tigase server may work for many virtual hosts so"
" the hostname part is added by the lower level functions and we only "
"provide the component name here. The second parameter is the service "
"discovery node which is usually '**null**' for top level disco elements. "
"Third is the item description (which is actually called 'name' in the "
"disco specification). The last parameter specifies if the element is "
"visible to administrators only."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:567
msgid "|spam filter counter small|"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:789
msgid "spam filter counter small"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:569
msgid ""
"The complete method code is presented below and the screenshot above "
"shows how the element of the service discovery for our component can "
"change if we apply our code and send a few messages to the component."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:571
msgid ""
"Using the method we can also add submodes to our component element. The "
"XMPP service discovery really is not for showing application counters, "
"but this case it is good enough to demonstrate the API available in "
"Tigase so we continue with presenting our counters via service discovery."
" This time, instead of using 'null' as a node we put some meaningful "
"texts as in example below:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:584
msgid ""
"Again, have a look at the full method body below for a complete code "
"example. Now if we send a few messages to the component and some of them "
"are spam (contain words recognized as spam) we can browse the service "
"discovery of the server. Your service discovery should show a list "
"similar to the one presented on the screenshot on the left."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:586
msgid ""
"Of course depending on the implementation, initially there might be no "
"sub-nodes under our component element if we call the "
"``updateServiceDiscoveryItem(…​)`` method only when a message is "
"processed. To make sure that sub-nodes of our component show from the "
"very beginning you can call them in ``setProperties(…​)`` for the first "
"time to populate the service discovery with initial sub-nodes."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:588
msgid ""
"Please note, the ``updateServiceDiscoveryItem(…​)`` method is used for "
"adding a new item and updating existing one. There is a separate method "
"though to remove the item:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:595
msgid ""
"Actually only two first parameters are important: the **jid** and the "
"**node** which must correspond to the existing, previously created "
"service discovery item."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:597
msgid ""
"There are two additional variants of the *update* method which give you "
"more control over the service discovery item created. Items can be of "
"different categories and types and can also present a set of features."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:599
msgid ""
"The simpler is a variant which sets a set of features for the updated "
"service discovery item. There is a `document <http://xmpp.org/registrar"
"/disco-features.html>`__ describing existing, registered features. We are"
" creating an example which is going to be a spam filter and there is no "
"predefined feature for spam filtering but for purpose of this guide we "
"can invent two feature identification strings and set it for our "
"component. Let’s call ``update`` method with following parameters:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:606
msgid ""
"The best place to call this method is the ``setProperties(…​)`` method so"
" our component gets a proper service discovery settings at startup time. "
"We have set two features for the component disco: *tigase:x:spam-filter* "
"and *tigase:x:spam-reporting*. This method accepts a variable set of "
"arguments so we can pass to it as many features as we need or following "
"Java spec we can just pass an array of **Strings**."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:608
msgid ""
"Update your code with call presented above, and restart the server. Have "
"a look at the service discovery for the component now."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:610
msgid ""
"The last functionality might be not very useful for our case of the spam "
"filtering component, but it is for many other cases like MUC or PubSub "
"for which it is setting proper category and type for the service "
"discovery item. There is a document listing all currently registered "
"service discovery identities (categories and types). Again there is entry"
" for spam filtering. Let’s use the *automation* category and *spam-"
"filter* type and set it for our component:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:618
msgid ""
"Of course all these setting can be applied to any service discovery "
"create or update, including sub-nodes. And here is a complete code of the"
" component:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst
msgid "_ cil5"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:794
msgid "Component Implementation - Lesson 5 - Statistics"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:796
msgid ""
"In most cases you’ll want to gather some run-time statistics from your "
"component to see how it works, detect possible performance issues or "
"congestion problems. All server statistics are exposed and are accessible"
" via XMPP with ad-hoc commands, HTTP, JMX and some selected statistics "
"are also available via SNMP. As a component developer you don’t have to "
"do anything to expose your statistic via any of those protocols, you just"
" have to provide your statistics and the admin will be able to access "
"them any way he wants."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:798
msgid ""
"This lesson will teach you how to add your own statistics and how to make"
" sure that the statistics generation doesn’t affect application "
"performance."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:800
msgid "|spam statitics small|"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1015
msgid "spam statitics small"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:802
msgid ""
"Your component from the very beginning generates some statistics by "
"classes it inherits. Let’s add a few statistics to our spam filtering "
"component:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:816
msgid "The code should be pretty much self-explanatory."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:818
msgid ""
"You have to call ``super.getStatistics(…​)`` to update stats of the "
"parent class. ``StatisticsList`` is a collection which keeps all the "
"statistics in a way which is easy to update, search, and retrieve them. "
"You actually don’t need to know all the implementation details but if you"
" are interested please refer to the source code and JavaDoc "
"documentation."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:820
msgid ""
"The first parameter of the ``add(…​)`` method is the component name. All "
"the statistics are grouped by the component names to make it easier to "
"look at particular component data. Next is a description of the element. "
"The third parameter is the element value which can be any number or "
"string."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:822
msgid ""
"The last parameter is probably the most interesting. The idea has been "
"borrowed from the logging framework. Each statistic item has importance "
"level. Levels are exactly the same as for logging methods with **SEVERE**"
" the most critical and **FINEST** the least important. This parameter has"
" been added to improve performance and statistics retrieval. When the "
"**StatisticsList** object is created it gets assigned a level requested "
"by the user. If the ``add(…​)`` method is called with lower priority "
"level then the element is not even added to the list. This saves network "
"bandwidth, improves statistics retrieving speed and is also more clear to"
" present to the end-user."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:824
msgid ""
"One thing which may be a bit confusing at first is that, if there is a "
"numerical element added to statistics with **0** value then the Level is "
"always forced to **FINEST**. The assumption is that the administrator is "
"normally not interested **zero-value** statistics, therefore unless he "
"intentionally request the lowest level statistics he won’t see elements "
"with **zeros**."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:826
msgid ""
"The **if** statement requires some explanation too. Normally adding a new"
" statistics element is not a very expensive operation so passing it with "
"``add(…​)`` method at an appropriate level is enough. Sometimes, however "
"preparing statistics data may be quite expensive, like reading/counting "
"some records from database. Statistics can be collected quite frequently "
"therefore it doesn’t make sense to collect the statistics at all if there"
" not going to be used as the current level is higher then the item we "
"pass anyway. In such a case it is recommended to test whether the element"
" level will be accepted by the collection and if not skip the whole "
"processing altogether."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:828
msgid ""
"As you can see, the API for generating and presenting component "
"statistics is very simple and straightforward. Just one method to "
"overwrite and a simple way to pass your own counters. Below is the whole "
"code of the example component:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1017
#: ../../Tigase_Development/Component_Implementation.rst:1315
msgid ": _cil6:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1020
msgid "Component Implementation - Lesson 6 - Scripting Support"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1022
msgid ""
"Scripting support is a basic API built-in to Tigase server and "
"automatically available to any component at no extra resource cost. This "
"framework, however, can only access existing component variables which "
"are inherited by your code from parent classes. It can not access any "
"data or any structures you added in your component. A little effort is "
"needed to expose some of your data to the scripting API."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1024
msgid ""
"This guide shows how to extend existing scripting API with your component"
" specific data structures."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1026
msgid ""
"Integrating your component implementation with the scripting API is as "
"simple as the code below:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1040
msgid ""
"This way you expose two the component variables: ``badWords`` and "
"``whiteList`` to scripts under names the same names - two defined "
"constants. You could use different names of course but it is always a "
"good idea to keep things straightforward, hence we use the same variable "
"names in the component and in the script."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1042
msgid ""
"Almost done, almost…​ In our old implementation these two variables are "
"Java arrays of ``String``. Therefore we can only change their elements "
"but we can not add or remove elements from these structures inside the "
"script. This is not very practical and it puts some serious limits on the"
" script’s code. To overcome this problem I have changed the test "
"component code to keep bad words and whitelist in ``java.util.Set`` "
"collection. This gives us enough flexibility to manipulate data."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1044
msgid ""
"As our component is now ready to cooperate with the scripting API, I will"
" demonstrate now how to add remove or change elements of these "
"collections using a script and ad-hoc commands."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1046
msgid "|test comp newscript|"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1312
msgid "test comp newscript"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1048
msgid ""
"First, browse the server service discovery and double click on the test "
"component. If you use `Psi <http://psi-im.org/>`__ client this should "
"bring to you a new window with ad-hoc commands list. Other clients may "
"present available ad-hoc commands differently."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1050
msgid ""
"The screenshot below shows how this may look. You have to provide some "
"description for the script and an ID string. We use Groovy in this guide "
"but you can as well use any different scripting language."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1052
msgid "|badwords list script|"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1313
msgid "badwords list script"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1054
msgid ""
"Please refer to the Tigase scripting documentation for all the details "
"how to add support for more languages. From the Tigase API point of view "
"it all looks the same. You have to select a proper language from the "
"pull-down list on windows shown on the right. If your preferred language "
"is not on the list, it means it is not installed properly and Tigase is "
"unable to detect it."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1056
msgid ""
"The script to pull a list of current bad words can be as simple as the "
"following Groovy code:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1065
msgid ""
"As you see from the code, you have to reference your component variables "
"to a variables in your script to make sure a correct type is used. The "
"rest is very simple and is a pure scripting language stuff."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1067
msgid ""
"Load the script on to the server and execute it. You should receive a new"
" window with a list of all bad words currently used by the spam filter."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1069
msgid ""
"Below is another simple script which allows updating (adding/removing) "
"bad words from the list."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1111
msgid ""
"These two scripts are just the beginning. The possibilities are endless "
"and with the simple a few lines of code in your test component you can "
"then extend your application at runtime with scripts doing various "
"things; you can reload scripts, add and remove them, extending and "
"modifying functionality as you need. No need to restart the server, no "
"need to recompile the code and you can use whatever scripting language "
"you like."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1113
msgid ""
"Of course, scripts for whitelist modifications would look exactly the "
"same and it doesn’t make sense to attach them here."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1115
msgid ""
"Here is a complete code of the test component with the new method "
"described at the beginning and data structures changed from array of "
"**String*s to Java \\*Set**:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1318
msgid "Component Implementation - Lesson 7 - Data Repository"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1321
msgid "ConfigRepository"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1323
msgid ""
"There are cases when you want to store some data permanently by your "
"component. You can of course use the component configuration to provide "
"some database connection settings, implement your own database connector "
"and store records you need. There is, however, a very simple and useful "
"framework which allows you to read and store some data transparently in "
"either a database or a disk file. The framework also supports ad-hoc "
"command interface straight away so you can manipulate your component data"
" using an XMPP client."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1325
msgid ""
"In order to use it one needs to extend "
"``tigase.db.comp.ConfigRepository`` abstract class."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1328
msgid "Accessing UserRepository or AuthRepository"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1330
msgid ""
"To use **AuthRepository** or **UserRepository** you need only to declare "
"fields properly and annotated them with **@Inject**. This fields must be "
"part of a class managed by Tigase Kernel - class of a component or any "
"class annotated with **@Bean** annotation. For that classes proper "
"instances of repositories will be injected by dependency injection."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1332
msgid "**Example usage of AuthRepository and UserRepository.**"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1342
msgid "Accessing other repositories"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1344
msgid ""
"In order to have more freedom while accessing repositories it’s possible "
"to create and use custom repository implementation which implements "
"**DataSourceAware** interface."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1346
msgid ""
"For our example let’s assume it will be class implementing "
"**TestRepositoryIfc** and our implementation will be using JDBC. To make "
"it work, we need to define ``TestRepositoryIfc`` as a generic interface "
"extending ``DataSourceAware`` interface. ``DataSourceAware`` interface "
"will provide definition for methods required by Tigase XMPP Server "
"internals to initialize custom repository classes based on "
"``TestRepositoryIfc``."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1348
msgid "**TestRepositoryIfc.**"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1357
msgid ""
"Next we need to prepare our actual implementation of repository - class "
"responsible for execution of SQL statements. In this class we need to "
"implement all of methods from our interface and method **void "
"setDataSource(DataSource dataSource)** which comes from "
"**DataSourceAware** interface. In this method we need to initialize data "
"source, ie. create prepared statements. We should annotate our new class "
"with ``@Repository.Meta`` annotation which will allow Tigase XMPP Server "
"to find this class whenever class implementing ``TestRepositoryIfc`` and "
"with support for data source with jdbc URI."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1392
msgid ""
"As you can see we defined type of a data source generic parameter for "
"interface ``TestRepositoryIfc``. With that we make sure that only "
"instance implementing ``DataRepository`` interface will be provided and "
"thanks to that we do not need to cast provided instance of ``DataSource``"
" to this interface before any access to data source."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1394
msgid ""
"With that in place we need to create class which will take care of adding"
" support for multi-database setup. In our case it will be "
"**TestRepositoryMDBean**, which will take care of discovery of repository"
" class, initialization and re-injection of data source. It is required to"
" do so, as it was just mentioned our ``TestRepositoryMDBean`` will be "
"responsible for initialization of ``JDBCTestRepository`` (actually this "
"will be done by ``MDRepositoryBean`` which is extended by "
"``TestRepositoryMDBean``."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1431
msgid ""
"Most of this code will be the same in all implementations based on "
"``MDRepositoryBeanWithStatistics``. In our case only custom method is "
"**void addItem(…​)** which uses **getRepository(String domain)** method "
"to retrieve correct repository for a domain. This retrieval of actual "
"repository instance for a domain will need to be done for every custom "
"method of ``TestRepositoryIfc``."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1435
msgid ""
"It is also possible to extend ``MDRepositoryBean`` or "
"``SDRepositoryBean`` instead of ``MDRepositoryBeanWithStatistics``. "
"However, if you decide to extend abstract repository bean classes without"
" ``withStatistics`` suffix, then no statistics data related to usage of "
"this repository will be gathered. The only change, will be that you will "
"not need to pass interface class to constructor of a superclass as it is "
"not needed."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1439
msgid ""
"As mentioned above, it is also possible to extend ``SDRepostioryBean`` "
"and ``SDRepositoryBeanWithStatistics``. Methods which you would need to "
"implement are the same is in case of extending "
"``MDRepositoryBeanWithStatistics``, however internally "
"``SDRepositoryBean`` will not have support for using different repository"
" for different domain. In fact ``SDRepositoryBeanWithStatistics`` has "
"only one repository instance and uses only one data source for all "
"domains. The same behavior is presented by "
"``MDRepositoryBeanWithStatistics`` if only single ``default`` instance of"
" repository is configured. However, ``MDRepositoryBeanWithStatistics`` "
"gives better flexibility and due to that usage of ``SDRepositoryBean`` "
"and ``SDRepositoryBeanWithStatistics`` is discouraged."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1441
msgid ""
"While this is more difficult to implement than in previous version, it "
"gives you support for multi database setup and provides you with "
"statistics of database query times which may be used for diagnosis."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1443
msgid ""
"As you can also see, we’ve annotated **TestRepositoryMDBean** with "
"**@Bean** annotation which will force Tigase Kernel to load it every time"
" **TestComponent** will be loaded. This way it is possible to inject "
"instance of this class as a dependency to any bean used by this component"
" (ie. component, module, etc.) by just creating a field and annotating "
"it:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1452
msgid ""
"In **testRepository** field instance of **TestRepositoryMDBean** will be "
"injected."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1456
msgid ""
"If the class in which we intend to use our repository is deeply nested "
"within Kernel dependencies and we want to leverage automatic schema "
"versioning we have to implement ``tigase.kernel.beans.RegistrarBean`` in "
"our class!"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1459
msgid "Configuration"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1461
msgid ""
"Our class ``TestRepositoryMDBean`` is annotated with ``@Bean`` which sets"
" its name as ``repository`` and sets parent as ``TestComponent``. "
"Instance of this component was configured by use under name of ``test`` "
"in Tigase XMPP Server configuration file. As a result, all configuration "
"related to our repositories should be placed in ``repository`` section "
"placed inside ``test`` section."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1463
msgid "**Example.**"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1474
msgid "Defaults"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1476
msgid ""
"As mentioned above, if we use ``MDRepositoryBeanWithStatistics`` as our "
"base class for ``TestRepositoryMDBean``, then we may have different data "
"sources used for different domains. By default, if we will not configure "
"it otherwise, ``MDRepositoryBeanWithStatistics`` will create only single "
"repository instance named ``default``. It will be used for all domains "
"and it will, by default, use data source named the same as repository "
"instance - it will use data source named ``default``. This defaults are "
"equal to following configuration entered in the config file:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1489
msgid "Changing data source used by repository"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1491
msgid ""
"It is possible to make any repository use different data source than data"
" source configured under the same name as repository instance. To do so, "
"you need to set ``dataSourceName`` property of repository instance to the"
" name of data source which it should use."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1493
msgid ""
"**Example setting repository ``default`` to use data source named "
"``test``.**"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1506
msgid "Configuring separate repository for domain"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1508
msgid ""
"To configure repository instance to be used for particular domain, you "
"need to define repository with the same name as domain for which it "
"should be used. It will, by default, use data source with name equal "
"domain name."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1510
msgid ""
"**Separate repository for ``example.com`` using data source named "
"``example.com``.**"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1533
msgid ""
"**Separate repository for ``example.com`` using data source named "
"``test``.**"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1559
msgid ""
"In both examples presented above, for domains other than ``example.com``,"
" repository instance named ``default`` will be used and it will use data "
"source named ``default``."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1562
msgid "Repository Versioning"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1564
msgid ""
"It’s also possible to enable repository versioning capabilities when "
"creating custom implementation. There are a couple of parts/steps to "
"fully take advantage of this mechanism."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1566
msgid ""
"Each ``DataSource`` has a table ``tig_schema_versions`` which contains "
"information about component schema version installed in the database "
"associated with particular DataSource."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1569
msgid "Enabling version checking in implementation"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1571
msgid ""
"First of all, repository implementation should implement "
"``tigase.db.util.RepositoryVersionAware`` interface (all it’s methods are"
" defined by default) and annotate it with "
"``tigase.db.Repository.SchemaId``. For example .Repository annoted with "
"``SchemaId`` and implementing ``RepositoryVersionAware``"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1581
msgid ""
"This action alone will result in performing the check during Tigase XMPP "
"Server startup and initialisation of repository whether tables, indexes, "
"stored procedures and other elements are present in the configured data "
"source in the required version. By default, required version matches the "
"implementation version (obtained via call to "
"``java.lang.Package.getImplementationVersion()``), however it’s possible "
"to specify required version manually, either:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1583
msgid ""
"by utilizing ``tigase.db.util.RepositoryVersionAware.SchemaVersion`` "
"annotation:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1594
msgid ""
"or by overriding ``tigase.db.util.RepositoryVersionAware.getVersion`` "
"method:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1605
msgid "Handling wrong version and the upgrade"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1607
msgid ""
"To detect that version information in database is inadequate following "
"logic will take place:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1609
msgid ""
"if there is no version information in the database the service will be "
"stopped completely prompting to install the schema (either via ``update-"
"schema`` or ``install-schema`` depending on user preference);"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1611
msgid ""
"if there is an information about loaded component schema version in the "
"repository and the base part of the required schema version (i.e. taking "
"into account only *major.minor.bugfix* part) is different from the one "
"present in the repository then:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1613
msgid ""
"if the required version of the component schema is *final* (i.e. non "
"``SNAPSHOT``) the server will shutdown and print in the log file (namely "
"``logs/tigase-console.log``) terminal error forcing the user to upgrade "
"the schema;"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1615
msgid ""
"if the required version of the component schema is *non-final* (i.e. "
"having ``SNAPSHOT`` part) then there will be a warning printed in the log"
" file (namely ``logs/tigase-console.log``) prompting user to run the "
"upgrade procedure due to possible changes in the schema but the "
"*server*\\ **will not**\\ *stop*;"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1617
msgid ""
"Upgrade of the loaded schema in the database will be performed by "
"executing:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1623
msgid ""
"The above command will load current configuration, information about all "
"configured data sources and enabled components, and then perform upgrade "
"of the schema of each configured component in the appropriate data "
"source."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1625
msgid ""
"Depending on the type of the database (or specified annotation), how the "
"upgrade procedure is handled internally is slightly different."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1628
msgid "Relational databases (external handling)"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1630
msgid ""
"For all relational databases (MySQL, PostgreSQL, MS SQL Server, etc…) we "
"highly recommend storing complete database schema in external files with "
"following naming convention: "
"``<database_type>-<component_name>-<version>.sql``, for example complete "
"schema for our Test component version 0.0.5 intended for MySQL would be "
"stored in file named ``mysql-test-0.0.5.sql``. What’s more - schema files"
" must be stored under ``database/`` subdirectory in Tigase XMPP Server "
"installation directory."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1634
msgid ""
"this can be controlled with ``external`` property of "
"``Repository.SchemaId`` annotation, which defaults to \"true\", if set to"
" ``false`` then handling will be done as described in `Relational "
"databases (external handling) <#update-relational>`__"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1636
msgid "For example:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1638
msgid "``database/mysql-test-0.0.1.sql``"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1640
msgid "``database/mysql-test-0.0.2.sql``"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1642
msgid "``database/mysql-test-0.0.3.sql``"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1644
msgid "``database/mysql-test-0.0.4.sql``"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1646
msgid "``database/mysql-test-0.0.5.sql``"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1648
msgid ""
"During the upgrade process all required schema files will be loaded in "
"the ascending version order. Version range will depend on the conditions "
"and will follow simple rules:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1650
msgid ""
"Start of the range will start at the next version to the one currently "
"loaded in the database (e.g. if the current version loaded to the "
"database is ``0.0.3`` and we are deploying component version ``0.0.5`` "
"then SchemaLoader will try to load schema from files: ``database/mysql-"
"test-0.0.4.sql`` and ``database/mysql-test-0.0.5.sql``)"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1652
msgid ""
"If we are trying to deploy a *SNAPSTHOT* version of the component then "
"schema file matching that version will always be included in the list of "
"files to be loaded (e.g. if we are trying to deploy a nightly build with "
"component version ``0.0.5-SNAPSHOT`` and currently loaded schema version "
"in the database is ``0.0.5`` then SchemaLoader will include ``database"
"/mysql-test-0.0.5.sql`` in the list of files to be loaded)"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1654
msgid ""
"It’s also possible to skip above filtering logic and force loading all "
"schema files for particular component/database from ``database/`` "
"directory by appending ``--forceReloadAllSchemaFiles=true`` parameter to "
"the ``upgrade-schema``/``install-schema`` command."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1657
msgid "Non-relational databases (internal handling)"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1659
msgid ""
"If there is a need to handle database schema internally (for example for "
"cases like NoSQL databases or simply there is such preference) then it’s "
"possible to do so by setting ``external`` attribute of "
"``Repository.SchemaId`` annotation to ``false``:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1665
msgid ""
"In such case, ``updateSchema`` method from "
"``tigase.db.util.RepositoryVersionAware`` interface should be implemented"
" to handle installation/updating of the schema. It takes two arguments:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1667
msgid ""
"``Optional<Version> oldVersion`` - indicating current version of the "
"schema loaded to the database (if it’s present)"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1669
msgid ""
"``Version newVersion`` - indicating required version (either version of "
"component or specific version of the repository)"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1672
msgid "Setting required repository version in database"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1674
msgid ""
"Each versioned schema file should consist at the end code responsible for"
" setting appropriate version of the loaded schema in the form of Stored "
"Procedure call with the name of the component and the version as "
"parameters:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1676
msgid "Postgresql"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1684
msgid "MsSQL Server"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1693
msgid "MySQL"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1701
msgid "Derby"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1709
msgid ""
"In case of schema handled internally, after successful load (i.e. "
"execution of the implemented "
"``tigase.db.util.RepositoryVersionAware.updateSchema`` method returning "
"``tigase.db.util.SchemaLoader.Result.ok``) the version in the database "
"will be set to the current version of the component."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1711
msgid ""
"This allows (in case of schema handled externally) to load it by hand by "
"directly importing ``.sql`` files into database."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1716
msgid "Component Implementation - Lesson 8 - Lifecycle of a component"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1719
msgid "Initialization of a component"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1721
msgid "A startup hook in the Tigase is different from the shutdown hook."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1723
msgid ""
"This is because you cannot really tell when exactly the startup time is. "
"Is it when the application started, is it when configuration is loaded, "
"is it when all objects are initialized. And this might be even different "
"for each component. Therefore, in fact, there is no startup hook in "
"Tigase in the same sense as the shutdown hook."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1725
msgid ""
"There are a few methods which are called at startup time of a component "
"in the following order:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1727
msgid ""
"**Constructor** - there is of course constructor which has no parameters."
" However it does not guarantee that this instance of the component will "
"be used at all. The object could be created just to get default values of"
" a config fields and may be destroyed afterwards."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1729
msgid ""
"**Getters/Setters** - at second step of initialization of a component, "
"Kernel configures component by reading and setting values of fields "
"annotated with ``@ConfigField()`` annotation. If there is a public getter"
" or setter for the same name as an annotated field - it will be used."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1731
msgid ""
"**void beanConfigurationChanged(Collection<String> changedFields)** "
"*(optional)* - if component implements ``ConfigurationChangedAware`` "
"interface, this method will be called to notify component about fields "
"which values were changed. It is useful if case in which component "
"internals depends on configuration stored in more than one field, as it "
"allows you to reconfigure component internals only once."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1733
msgid ""
"**void register(Kernel kernel)** *(optional)* - if component implements "
"``RegistrarBean`` interface this method is called to allow registration "
"of component private beans."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1735
msgid ""
"**Dependency Injection** - during this time Kernel injects beans to "
"component fields annotated with ``@Inject``. If public getters or setters"
" for this fields exist - kernel will use them."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1737
msgid ""
"**void initialized()** *(optional)* - called if component implements "
"``Initializable`` interface to notify it that configuration is set and "
"dependencies are injected."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1739
msgid ""
"**void start()** - during this call component starts it’s internal jobs "
"or worker threads or whatever it needs for future activity. Component’s "
"queues and threads are initialized at this point. **(after this method "
"returns the component is ready)**"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1741
msgid ""
"Therefore, the ``start()`` hook is the best point if you want to be sure "
"that component is fully loaded, initialized and functional."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1745
msgid ""
"Component instance may be started and stopped only once, however new "
"instances of the same component with the same name may be created during "
"Tigase XMPP Server uptime, ie. as a result of a server reconfiguration."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1748
msgid "Reconfiguration"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1750
msgid ""
"During lifecycle of a component instance it may happen that Tigase XMPP "
"Server will be reconfigured. If change in configuration of this component"
" will not be related to it’s activity, then Kernel will set values of "
"changes fields annotated with ``@ConfigField()``. In this case public "
"field setters may be used."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1754
msgid ""
"If component implements ``ConfigurationChangedAware`` interface, then "
"method **void beanConfigurationChanged(Collection<String> "
"changedFields)** will be called to notify component about fields which "
"values were changed. It is useful if same component internal depends on "
"configuration stored in more than one field, as it allows you to "
"reconfigure this internal once."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1757
msgid "Update of injected dependencies"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1759
msgid ""
"During lifecycle of a component instance it may happen that due to "
"reconfiguration of a server other bean needs to be injected as a "
"dependency to a component. In this case Tigase Kernel will inject "
"dependencies to fields annotated with ``@Inject`` which value needs to be"
" updated."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1762
msgid "Stopping a component"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1764
msgid ""
"Component instance may be stopped at any point of Tigase XMPP Server "
"runtime, ie. due to reconfiguration, or due to server graceful shutdown."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1766
msgid "In both cases following methods of a component will be called:"
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1768
msgid "**void stop()** - first method stops component internal processing queues."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1770
msgid ""
"**void beforeUnregister()** *(optional)* - if component implements "
"@UnregisterAware@ interface this method is called to notify instance of a"
" component that it is being unloaded."
msgstr ""

#: ../../Tigase_Development/Component_Implementation.rst:1772
msgid ""
"**void unregister(Kernel kernel)** *(optional)* - if component implements"
" ``RegistrarBean`` called to give component a way to unregister beans (if"
" needed)."
msgstr ""

