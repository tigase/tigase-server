# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2022, Tigase, Inc
# This file is distributed under the same license as the TigaseDoc package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: TigaseDoc\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-27 19:27-0700\n"
"PO-Revision-Date: 2022-07-26 09:14+0000\n"
"Last-Translator: Qian Luo <qian.luo@tigase.net>\n"
"Language-Team: Chinese (Simplified) <http://translate.tigase.net/projects/"
"tigase-xmpp-server/security/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.11.2\n"
"Generated-By: Babel 2.8.0\n"

#: ../../Tigase_Administration/Security/_Security.rst:2
msgid "Security"
msgstr "安全"

#: ../../Tigase_Administration/Security/_Security.rst:4
msgid ""
"The articles here cover advanced security features built into to Tigase "
"Server, and some options for adding your own levels of security."
msgstr "此处的文章涵盖了 Tigase Server "
"内置的高级安全功能，以及一些用于添加您自己的安全级别的选项。"

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:2
msgid "XEP-0191: Blocking Command"
msgstr "XEP-0191：阻止命令"

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:4
msgid ""
"The simplest security feature, however, inside an XMPP server is the "
"ability to block users and JIDS. `XEP-0191 "
"<http://xmpp.org/extensions/xep-0191>`__ specifies the parameters of "
"simple blocking without using privacy lists. Below is a breakdown and "
"some sample commands you may find helpful. To enable this feature, be "
"sure the following is in your ``config.tdsl`` file:"
msgstr ""
"然而，XMPP 服务器中最简单的安全功能是阻止用户和 JIDS 的能力。 `XEP-0191 "
"<http://xmpp.org/extensions/xep-0191>`__ 指定不使用隐私列表的简单屏蔽的参数。"
"以下是细分和一些您可能会发现有用的示例命令。要启用此功能，请确保您的 ``config"
".tdsl`` 文件中包含以下内容："

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:13
msgid ""
"If you have other plugins running, then just add ``'urn:xmpp:blocking' ()"
" {}`` to the list to activate this feature."
msgstr "如果您有其他插件正在运行，那么只需将 ``'urn:xmpp:blocking' () {}`` "
"添加到列表中以激活此功能。"

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:15
msgid ""
"To confirm if your installation of Tigase supports this feature, a quick "
"disco#info of your server should reveal the following feature:"
msgstr "要确认您安装的 Tigase 是否支持此功能，您的服务器的快速 disco#info "
"应显示以下功能："

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:21
msgid ""
"Blocked users are stored on the server on a per-JID basis, so one user "
"may only see his or her blocked JIDs. Lists of blocked JIDs will return "
"as an IQ stanza with a list of <item> fields. To retrieve the blocklist, "
"the following command is issued:"
msgstr ""
"被阻止的用户以每个 JID 为基础存储在服务器上，"
"因此一个用户可能只能看到他或她被阻止的 JIDs。被阻止的 JIDs 列表将作为带有 "
"<item> 字段列表的 IQ 节返回。要检索阻止列表，发出以下命令："

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:29
msgid "The server responds:"
msgstr "服务器响应："

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:40
msgid ""
"To block a JID, a similar stanza to the one above is sent to the server "
"with the items of the blocked JIDs you wish to add:"
msgstr "要阻止 JID，将与上述类似的节发送到服务器，其中包含您希望添加的被阻止 JID "
"的项目："

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:50
msgid ""
"The server will then push an unavailable presence to blocked contacts. "
"Communication between a contact that is blocked, and an entity that "
"blocked it will result in a <not-acceptable> error:"
msgstr "然后，服务器会将不可用的状态推送给被阻止的联系人。"
"被阻止的联系人与阻止它的实体之间的通信将导致 <not-acceptable> 错误："

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:62
msgid ""
"Unblocking a contact is just as easy as blocking, send an unblock stanza "
"to the server:"
msgstr "取消阻止联系人就像阻止一样简单，向服务器发送取消阻止节："

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:72
msgid ""
"The server will begin pushing presence information to unblocked contacts "
"and resources so long as permissions have not changed between."
msgstr "只要权限没有改变，服务器就会开始向未阻止的联系人和资源推送存在信息。"

#: ../../Tigase_Administration/Security/XEP-0191_Blocking_Command.inc:74
msgid ""
"You may also opt to unblock all contacts and essentially clear out your "
"blocked list using the following command:"
msgstr "您也可以选择取消阻止所有联系人，并使用以下命令从根本上清除您的阻止列表："

#: ../../Tigase_Administration/Security/Account_Registration_Limits.inc:2
msgid "Account Registration Limits"
msgstr "帐户注册限制"

#: ../../Tigase_Administration/Security/Account_Registration_Limits.inc:4
msgid ""
"In order to protect Tigase servers from DOS attacks, a limit on number of"
" account registrations per second has been implemented. This may be "
"configured by adding the following line in the ``config.tdsl`` file:"
msgstr ""
"为了保护 Tigase 服务器免受 DOS 攻击，已经限制了每秒帐户的注册数量。"
"这可以通过在 ``config.tdsl`` 文件中添加以下行来配置："

#: ../../Tigase_Administration/Security/Account_Registration_Limits.inc:11
msgid ""
"This setting allows for 10 registrations from a single IP per second. If "
"the limit is exceeded, a ``NOT_ALLOWED`` error will be returned."
msgstr "此设置允许每秒从单个 IP 进行 10 次注册。如果超出限制，将返回 ``NOT_ALLOWED`` "
"错误。"

#: ../../Tigase_Administration/Security/Account_Registration_Limits.inc:13
msgid "It is possible to create two separate counters as well:"
msgstr "也可以创建两个单独的计数器："

#: ../../Tigase_Administration/Security/Account_Registration_Limits.inc:26
msgid ""
"Here we have one for c2s with a limit of 3, and a global for all other "
"connection managers set at 10."
msgstr "在这里，我们有一个用于 c2s 的计数器其限制为 3，"
"而另外一个用于所有其他连接管理器的全局设置为 10。"

#: ../../Tigase_Administration/Security/Account_Registration_Limits.inc:28
msgid "You can also set individual components limits as well:"
msgstr "您还可以设置单个组件限制："

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:2
msgid "Brute-force attack prevention"
msgstr "暴力攻击预防"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:4
msgid ""
"Brute-force Prevention is designed to protect Tigase Server against user "
"password guessing. It counts invalid login tries and when it is above "
"limit, it locks login ability for specific time (soft ban). When invalid "
"login counter reaches second level, account will be disabled permanently."
msgstr ""
"暴力预防旨在保护 Tigase 服务器不会被猜测的用户密码破解。它计算无效的登录尝试"
"，当它超过限制时，它会锁定特定时间的登录能力（软禁令）。当无效登录计数器达到"
"第二级时，帐户将被永久禁用。"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:7
#: ../../Tigase_Administration/Security/Packet_Filtering.inc:49
msgid "Configuration"
msgstr "配置"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:9
msgid ""
"Brute-force Prevention is configured by VHost. There is following lis of "
"configuration parameters:"
msgstr "暴力防护由 VHost 配置。有以下配置参数列表："

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:12
#, fuzzy
msgid "``brute-force-lock-enabled``"
msgstr "``brute-force-lock-enabled``"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:12
#, fuzzy
msgid "``boolean``"
msgstr "``boolean``"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:12
msgid "Brute Force Prevention Enabled"
msgstr "启用暴力预防"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:14
#, fuzzy
msgid "``brute-force-lock-after-fails``"
msgstr "``brute-force-lock-after-fails``"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:14
#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:16
#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:18
#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:20
#, fuzzy
msgid "``long``"
msgstr "``long``"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:14
msgid "Number of allowed invalid login"
msgstr "允许的无效登录次数"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:16
#, fuzzy
msgid "``brute-force-period-time``"
msgstr "``brute-force-period-time``"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:16
msgid "Time [sec] in what failed login tries are counted"
msgstr "计算失败登录尝试的时间 [秒]"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:18
#, fuzzy
msgid "``brute-force-disable-after-fails``"
msgstr "``brute-force-disable-after-fails``"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:18
msgid "Threshold beyond which account will be permanently disabled"
msgstr "帐户将被永久禁用的阈值"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:20
#, fuzzy
msgid "``brute-force-lock-time``"
msgstr "``brute-force-lock-time``"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:20
msgid "Time [sec] of soft ban (first threshold)"
msgstr "软禁令的时间[秒]（第一个阈值）"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:22
#, fuzzy
msgid "``brute-force-mode``"
msgstr "``brute-force-mode``"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:22
#, fuzzy
msgid "``string``"
msgstr "``string``"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:22
msgid "Working mode (see `Working modes <#bruteForcePrevention_WorkingModes>`__)"
msgstr "工作模式（参见 :ref:`工作模式<bruteForcePrevention_WorkingModes>`）"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:26
msgid "Detailed statistics"
msgstr "详细统计"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:28
msgid ""
"By default, in order not to pollute statistics, Brute-Force locker will "
"only provide details about number of locker IPs and JIDs (and total "
"number of locked attempts). In order to have detailed information about "
"IPs and JIDs that has been locked in statistics you should use following "
"configuration:"
msgstr ""
"默认情况下，为了不污染统计数据，Brute-Force locker 将仅提供有关 locker IP 和 "
"JID 数量（以及锁定尝试总数）的详细信息。为了获得相关已锁定在统计信息中的 IP "
"和 JID 的详细信息，您应该使用以下配置："

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:39
msgid "Working modes"
msgstr "工作模式"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:41
msgid "There are three working modes:"
msgstr "共有三种工作模式："

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:43
msgid ""
"``Ip`` - it counts invalid login tries from IP, and locks login ability "
"(soft ban) for IP what reach the threshold"
msgstr "``Ip`` - 它计算来自 IP 的无效登录尝试，并锁定达到阈值的 IP 的登录（软禁令）"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:45
msgid ""
"``IpJid`` - it counts tries from IP to specific user account. Soft ban "
"locks ability of login to specific JID from specific IP."
msgstr "``IpJid`` - 它计算从 IP 到特定用户帐户的尝试。软禁令锁定从特定 IP 登录特定 "
"JID 的能力。"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:47
msgid ""
"``Jid``- similar to ``IpJid`` but checks only JID. Soft ban locks ability"
" of login to specific JID from all IPs."
msgstr "``Jid``- 类似于 ``IpJid`` 但只检查 JID。软禁令锁定从所有 IP 登录到特定 JID "
"的能力。"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:54
msgid "Permanent ban"
msgstr "永久禁令"

#: ../../Tigase_Administration/Security/Brute-force_attack_prevention.inc:56
msgid ""
"In modes ``Jid`` and ``IpJid``, when invalid login counter reach "
"threshold ``brute-force-disable-after-fails``, account status will be set"
" o ``disabled``. To enable it again you should use `Re-Enable User "
"<https://xmpp.org/extensions/xep-0133.html#reenable-users>`__ Ad-hoc "
"Command."
msgstr ""
"在 ``Jid`` 和 ``IpJid`` 模式下，当无效登录计数器达到 ``brute-force-disable-"
"after-fails`` 阈值时，帐户状态将设置为 ``disabled``。要再次启用它，"
"您应该使用 `Re-Enable User <https://xmpp.org/extensions/xep-0133.html"
"#reenable-users>`__ Ad-hoc 命令。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:2
#: ../../Tigase_Administration/Security/Server_Certificates.inc:12
msgid "Server Certificates"
msgstr "服务器证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:4
msgid ":ref:`Creating and Loading the Server Certificate in pem Files<certspem>`"
msgstr ":ref:`在 pem 文件中创建和加载服务器证书<certspem>`"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:9
msgid "Creating and Loading the Server Certificate in pem Files"
msgstr "在 pem 文件中创建和加载服务器证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:14
msgid ""
"Server certificates are needed when you use secure socket connections - "
"SSL/TLS."
msgstr "使用安全套接字连接时需要服务器证书 - SSL/TLS。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:16
msgid ""
"For secure socket connection a proper certificate is needed. You can "
"either generate your own self-signed certificate or obtain certificate "
"from trusted third party organization."
msgstr "对于安全套接字连接，需要适当的证书。您可以生成自己的自签名证书或从受信任的第"
"三方组织获取证书。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:18
msgid "Here are steps how to obtain certificate from a trusted organization."
msgstr "以下是如何从受信任的组织获取证书的步骤。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:20
msgid "Generating your Own Certificates"
msgstr "生成您自己的证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:22
msgid ""
"Self-signed certificates can be generated easily on a Linux system. "
"Although it may not be considered a 'trusted' certificate authority, it "
"can be useful to test server installations. **We do not recommend regular"
" use of self-signed certificates**."
msgstr ""
"在 Linux 系统上可以轻松生成自签名证书。尽管它可能不被视为'信任的'证书颁发机构"
"，但它对测试服务器安装很有用。 **我们不建议经常使用自签名证书**。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:26
msgid ""
"that Tigase v5.0 and later can automatically create self signed PEM files"
" if needed. However we will cover doing this process by hand."
msgstr "Tigase v5.0 及更高版本可以在需要时自动创建自签名 PEM "
"文件。但是，我们将介绍手动如何执行此过程。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:28
msgid ""
"This tutorial assumes you are running a Linux-based operating system with"
" access to command shell, and the 'Openssl' package is installed on the "
"system."
msgstr "本教程假设您正在运行基于 Linux 的操作系统，可以访问命令 shell，"
"并且系统上安装了 'Openssl' 包。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:30
msgid "The process takes the following steps:"
msgstr "该过程采取以下步骤："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:31
msgid ""
"1. Create a local private key. This file ends with .key extension. It is "
"recommended to create a new private key for the process."
msgstr "1. 创建本地私钥。此文件以 .key 扩展名结尾。建议为该进程创建一个新的私钥。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:32
msgid ""
"2. Generate a certificate request. This file ends with the .csr extension"
" and is the file sent to the Certificate Authority to be signed."
msgstr "2. 生成证书请求。此文件以 .csr "
"扩展名结尾，是发送给证书颁发机构以进行签名的文件。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:33
msgid ""
"3. CA signs private key. This can be done by your own computer, but can "
"also be done by private CAs for a fee."
msgstr "3. CA 签署私钥。这可以通过您自己的计算机完成，但也可以由私人 CAs "
"完成，但需要付费。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:34
msgid ""
"4. Results are obtained from the CA. This is a ``.crt`` file which "
"contains a separate public certificate."
msgstr "4. 结果来自 CA。这是一个 ``.crt`` 文件，其中包含一个单独的公共证书。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:35
msgid ""
"5. Combine the ``.csr`` and ``.crt`` file into a unified ``.pem`` file. "
"Tigase requires keys to be non-password protected PEM files."
msgstr ""
"5. 将 ``.csr`` 和 ``.crt`` 文件合并成一个统一的 ``.pem`` 文件。 Tigase "
"要求密钥是不受密码保护的 PEM 文件。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:37
msgid "**Generate local private key.**"
msgstr "**生成本地私钥。**"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:43
msgid ""
"This command generates a private key using a 1024 bit RSA algorithm. "
"``-out`` designates the name of the file, in this case it will be "
"``domain.com.key``. The exact name is not important, and the file will be"
" created in whatever directory you are currently in."
msgstr ""
"此命令使用 1024 位 RSA 算法生成私钥。 ``-out`` 指定文件的名称，"
"在这种情况下它将是 ``domain.com."
"key``。确切的名称并不重要，文件将在您当前所在的任何目录中创建。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:45
msgid "**Generate a certificate request:.**"
msgstr "**生成证书请求：**"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:51
msgid ""
"This command generates a certificate request using the file specified "
"after ``-key``, and the result file will be ``domain.com.csr``. You will "
"be asked a series of questions to generate the request."
msgstr "该命令使用 ``-key`` 之后指定的文件生成证书请求，结果文件将是 ``domain.com."
"csr``。您将被问到一系列问题以生成请求。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:68
msgid "**Sign the Certificate Request:.**"
msgstr "**签署证书请求：**"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:70
msgid ""
"Now the .csr file will be signed by a Certificate Authority. In this "
"tutorial, we will be self-signging our certificate. This practice however"
" is generally not recommended, and you will receive notifications that "
"your certificate is not trusted. There are commercial offers from "
"companies to sign your certificate from trusted sources. Please see the "
":ref:`Certificate From Other Providers<OtherSources>` section for more "
"information."
msgstr ""
"现在 .csr 文件将由证书颁发机构签名。在本教程中，我们将自签名我们的证书。但是"
"，通常不建议采用这种做法，并且您会收到有关您的证书不受信任的通知。公司提供商"
"业报价以从受信任的来源签署您的证书。有关更多信息，请参阅 "
":ref:`来自其他提供商的证书<OtherSources>` 部分。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:76
msgid ""
"This command signs the certificate for 365 days and generates the "
"``domain.com.crt`` file. You can, of course use any number of days you "
"like."
msgstr "此命令证书签名 365 天并生成 ``domain.com.crt`` "
"文件。当然，您可以使用任意天数。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:78
msgid "**Generate PEM file.**"
msgstr "**生成 PEM 文件。**"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:80
msgid ""
"You should now have the following files in the working directory: ..\\\\ "
"domain.com.key domain.com.csr domain.com.crt"
msgstr "您现在应该在工作目录中有以下文件：..\\\\ domain.com.key domain.com.csr domain"
".com.crt"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:86
msgid ""
"If the certificate is issued by third-party authority you will have to "
"attach the certificate chain, that being certificate of the authority who"
" has generated your certificate. You normally need to obtain certificates"
" for your chain from the authority who has generated your certificate."
msgstr "如果证书是由第三方机构颁发的，您必须附加证书链，即生成您的证书的机构的证书。"
"您通常需要从生成您的证书的机构获取您的链的证书。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:88
msgid "The result file should looks similar to:"
msgstr "结果文件应类似于："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:114
msgid ""
"For Tigase server as well as many other servers (Apache 2.x), the order "
"is following; your domain certificate, your private key, authority "
"issuing your certificate, root certificate."
msgstr "对于 Tigase 服务器以及许多其他服务器（Apache 2."
"x），顺序如下；您的域证书，您的私钥，颁发证书的机构，根证书。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:118
msgid ""
"Tigase requires full certificate chain in PEM file (described above)! "
"Different applications may require pem file with certificates and private"
" key in different order. So the same file may not be necessarily used by "
"other services like Web server or e-mail server. Currently, Tigase can "
"automatically sort certificates in PEM file while loading it.**"
msgstr ""
"**Tigase 需要 PEM 文件中的完整证书链（如上所述）！"
"不同的应用程序可能需要具有不同顺序的证书和私钥的 pem 文件。因此，Web "
"服务器或电子邮件服务器等其他服务不一定会使用相同的文件。目前，Tigase "
"可以在加载 PEM 文件时自动对证书进行排序。**"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:123
msgid "Installing/Loading Certificate To the Tigase Server"
msgstr "将证书安装/加载到 Tigase 服务器"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:125
msgid ""
"Installing and loading certificates is very easy. The server can load all"
" certificates directly from **pem** files. You just need to create a "
"separate pem file for each of your virtual domains and put the file in a "
"directory accessible by the server. Tigase server can automatically load "
"all **pem** files found in given directory. By default, and to make "
"things easy, we recommend the ``Tigase/certs`` directory."
msgstr ""
"安装和加载证书非常容易。服务器可以直接从 **pem** 文件加载所有证书。"
"您只需为每个虚拟域创建一个单独的 pem "
"文件，并将该文件放在服务器可访问的目录中。 Tigase "
"服务器可以自动加载在给定目录中找到的所有 **pem** "
"文件。默认情况下，为了方便起见，我们推荐使用 ``Tigase/certs`` 目录。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:127
msgid ""
"It’s also possible to use: \\* Admin ad-hoc command via XMPP client - you"
" should navigate to Service Discovery of your server and in the list of "
"commands for ``VHost Manager`` component select ``Add SSL Certificate`` "
"and then follow instructions \\* Admin WebUI - open "
"``http://<host>/admin``, navigate to ``Other`` category and in it select "
"``Add SSL Certificate`` and then follow instructions \\* REST API - make "
"a ``POST`` request to ``http://localhost:8080/rest/adhoc/vhost-"
"man@domain.com`` with payload containing your certificate; to get the "
"required form fields make ``GET`` request to the same endpoint"
msgstr ""
"也可以使用：\\* Admin ad-hoc 命令通过 XMPP 客户端 - "
"您应该访问到服务器的服务发现并在 ``VHost Manager`` 组件的命令列表中选择 ``"
"Add SSL Certificate``，然后按照说明\\* Admin WebUI - 打开 "
"``http://<host>/admin``，访问 ``Other``类别并在其中选择 ``Add SSL "
"Certificate``，然后按照说明\\* REST API -使用包含您的证书的有效负载向 "
"``http://localhost:8080/rest/adhoc/vhost-man@domain.com`` 发出 ``POST`` "
"请求；为获取所需的表单字段，请向同一端点发出 ``GET`` 请求"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:132
msgid "Certificate From Other Providers"
msgstr "来自其他提供商的证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:134
msgid ""
"There is number of certificate providers offering certificates either for"
" free or for money. You can use any of them, however you have to be aware"
" that sometimes certificates might not be recognized by all XMPP servers,"
" especially if it’s one from a new provider. Here is an example list of "
"providers:"
msgstr ""
"有许多证书提供商免费或有偿提供证书。您可以使用其中的任何一个，但是您必须注意"
"，有时证书可能无法被所有 XMPP "
"服务器识别，特别是如果它是来自新提供商的证书。以下是提供商的示例列表："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:136
msgid ""
"LetsEncrypt - please see `Installing LetsEncrypt Certificates in Your "
"Linux System<LetsEncryptCertificate>` for details"
msgstr ""
"LetsEncrypt - 有关详细信息，请参阅 :ref:`在 Linux 系统中安装 LetsEncrypt "
"证书<LetsEncryptCertificate>`"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:138
msgid ""
"`CAcert <https://www.cacert.org/>`__ - free certificates with Web GUI. "
"(WARNING: it’s not widely accepted)"
msgstr "`CAcert <https://www.cacert.org/>`__ - 带有 Web GUI "
"的免费证书。(警告：它没有被广泛接受）"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:140
msgid ""
"`Verisign <https://www.verisign.com/>`__ - very expensive certificates "
"comparing to above provides but the provider is recognized by everybody. "
"If you have a certificate from Verisign you can be sure it is identified "
"as a valid certificate."
msgstr ""
"`Verisign <https://www.verisign.com/>`__ - "
"与上述提供的证书相比，此证书非常昂贵，但此证书的提供者得到了所有人的认可。"
"如果您拥有来自 Verisign 的证书，则可以确定此为有效证书。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:142
msgid ""
"`Comodo Certificate Authority <http://www.comodo.com/business-security"
"/digital-certificates/ssl-certificates.php>`__ offers different kind of "
"commercial certificates"
msgstr ""
"`Comodo 证书颁发机构 <http://www.comodo.com/business-security/"
"digital-certificates/ssl-certificates.php>`__ 提供不同类型的商业证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:144
msgid ""
"To obtain certificate from a third party authority you have to go to its "
"website and request the certificate using certificate request generated "
"above. I cannot provide any instructions for this as each of the "
"providers listed have different requirements and interfaces."
msgstr "要从第三方机构获取证书，您必须访问其网站并使用上面生成的证书请求来请求证书。"
"我无法为此提供任何说明，因为列出的每个提供商都有不同的要求和接口。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:146
msgid ""
"We **highly** recommend using LetsEncrypt keys to self-sign and secure "
"your domain. Instructions are in the :ref:`next "
"section<LetsEncryptCertificate>`."
msgstr ""
"我们 **强烈** 建议使用 LetsEncrypt 密钥进行自签名并保护您的域。说明在 "
":ref:`下一节<LetsEncryptCertificate>`"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:149
msgid "Using one certificate for multiple domains"
msgstr "对多个域使用一个证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:153
msgid ""
"Tigase tries to be *smart* and automatically detects wildcard domain and "
"alternative domains so it’s not needed to duplicate same certificate in "
"multiple files to match domains - same file will be loaded and make "
"available for all domains (CNames) available in the certificate."
msgstr ""
"Tigase 尝试变得 *智能*，并自动检测通配符域和备用域，"
"因此无需在多个文件中复制相同的证书以匹配域 - "
"相同的文件将被加载并使其可用于证书中可用的所有域 (CNames)。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:158
msgid "Installing LetsEncrypt Certificates in Your Linux System"
msgstr "在 Linux 系统中安装 LetsEncrypt 证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:160
msgid ""
"LetsEncrypt is a trusted CA that provides free security certificates. "
"Unlike previously self-signed certificates, we can use LetsEncrypt "
"Certificates to certify your domains from a trusted source."
msgstr ""
"LetsEncrypt 是一个可信任的 CA，提供免费的安全证书。与以前的自签名证书不同，"
"我们可以使用 LetsEncrypt 证书从受信任的来源认证您的域。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:162
msgid ""
"Please refer to official `certbot User Guide "
"<https://certbot.eff.org/docs/using.html>`__ for details how to install "
"and operate the tool, choosing desired method of domain authentication "
"(DNS or webserver). After successful execution the certificate with all "
"related files will be stored under ``/etc/letsencrypt/live/$domain``"
msgstr ""
"请参考官方 `certbot用户指南 <https://certbot.eff.org/docs/using.html>`__ 了解"
"如何安装和操作该工具，选择所需的域认证方法（DNS或网络服务器）。成功执行后，"
"所有相关文件的证书将存储在 ``/etc/letsencrypt/live/$domain`` 下"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:169
msgid "In that directory, you will find four files:"
msgstr "在该目录中，您将找到四个文件："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:171
msgid "``privkey.pem`` - private key for the certificate"
msgstr "``privkey.pem`` - 证书的私钥"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:173
msgid "``cert.pem`` - contains the server certificate by itself"
msgstr "``cert.pem`` - 本身包含服务器证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:175
msgid ""
"``chain.pem`` - contains the additional intermediate certificate or "
"certificates"
msgstr "``chain.pem`` - 包含额外的中间证书或证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:177
msgid ""
"``fullchain.pem`` - all certificates, including server certificate (aka "
"leaf certificate or end-entity certificate). The server certificate is "
"the first one in this file, followed by any intermediates."
msgstr ""
"``fullchain.pem`` - 所有证书，包括服务器证书（又名叶子证书或最终实体证书）。"
"服务器证书是此文件中的第一个证书，然后是任何中间证书。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:179
msgid ""
"For Tigase XMPP Server, we are only concerned with ``privkey.pem`` and "
"``fullchain.pem`` (or ``chain.pem`` - please consider actual issuers and "
"certification chain!)."
msgstr ""
"对于 Tigase XMPP 服务器，我们只关心 ``privkey.pem`` 和 ``fullchain.pem`` (或 "
"``chain.pem`` - 请考虑实际的颁发者和认证链！)。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:181
msgid ""
"At this point we will need to obtain the root and intermediate "
"certificates, this can be done by downloading these certificates from the"
" `LetsEncrypt Chain of Trust website "
"<https://letsencrypt.org/certificates/>`__."
msgstr ""
"此时我们需要获取根证书和中间证书，这可以通过从 `LetsEncrypt Chain of Trust "
"website <https://letsencrypt.org/certificates/>`__ 下载这些证书来完成。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:185
msgid ""
"Please pay utmost attention to the actual certificate issuers and make "
"sure that the certification chain is maintained!"
msgstr "请高度关注实际的证书颁发者，并确保维护证书链！"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:187
msgid ""
"On the time of the writing, LetsEncrypt was providing domain certificates"
" issued by ``R3`` CertificateAuthorigy (CA). In order to provide complete"
" chain to the root CA you should get Let’s Encrypt R3 (``RSA 2048, O = "
"Let’s Encrypt, CN = R3``) certificate. Depending on desired certification"
" chain you have two options: 1) (default and recommended) using own "
"LetsEncrypt CA: a) ``R3`` certificate signed by ISRG Root X1: "
"https://letsencrypt.org/certs/lets-encrypt-r3.pem b) ``ISRG Root X1`` "
"root certificate: https://letsencrypt.org/certs/isrgrootx1.pem 2) "
"(legacy, option more compatible with old systems): cross-signed "
"certificate by IdenTrust: a) ``R3`` certificate cross-signed by "
"IdenTrust: https://letsencrypt.org/certs/lets-encrypt-r3-cross-signed.pem"
" b) ``TrustID X3 Root`` from IdenTrust: "
"https://letsencrypt.org/certs/trustid-x3-root.pem.txt"
msgstr ""
"在撰写本文时，LetsEncrypt 提供由 ``R3`` CertificateAuthorigy (CA) "
"颁发的域证书。为了向根 CA 提供完整的链，您应该获得 Let's Encrypt R3 (``RSA "
"2048, O = Let's Encrypt, CN = R3``) "
"证书。根据所需的证书链，您有两个选择：1）（默认和推荐）使用自己的 "
"LetsEncrypt CA：a）由 ISRG 根 X1 签名的 ``R3`` 证书：https://letsencrypt.org/"
"certs/lets-encrypt-r3.pem b) ``ISRG Root X1`` 根证书：https://letsencrypt."
"org/certs/isrgrootx1.pem 2)（旧版，与旧系统更兼容的选项）：IdenTrust "
"的交叉签名证书：a)由 IdenTrust 交叉签名的 ``R3`` 证书：https://letsencrypt."
"org/certs/lets-encrypt-r3-cross-signed.pem b) 来自 IdenTrust 的 ``TrustID X3 "
"Root`` ：https://letsencrypt.org/certs/trustid-x3-root.pem.txt"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:189
msgid "Considering first (recommended) option, you may obtain them using wget:"
msgstr "考虑到第一个（推荐）选项，您可以使用 wget 获取它们："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:196
msgid ""
"These are the root certificate, and the intermediate certificate signed "
"by root certificate."
msgstr "这些是根证书，以及由根证书签名的中间证书。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:200
msgid ""
"IdenTrust cross-signed certificate will not function properly in the "
"future!"
msgstr "IdenTrust 交叉签名证书以后将无法正常运行！"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:202
msgid ""
"Take the contents of your ``privkey.pem``, certificate, and combine them "
"with the contents of ``isrgrootx1.pem`` and ``lets-encrypt-r3.pem`` into "
"a single pem certificate."
msgstr ""
"获取您的 ``privkey.pem`` 证书的内容，并将它们与 ``isrgrootx1.pem`` 和 ``lets-"
"encrypt-r3.pem`` 的内容组合成一个单独的pem证书。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:204
msgid ""
"Depending on your configuration you either need to name the file after "
"your domain such as ``mydomain.com.pem`` and place it under ``certs/`` "
"subdirectory of Tigase XMPP Server installation or update it using admin "
"ad-hoc (see :ref:`Storing and managing certificates<certificateStorage>`)"
msgstr ""
"根据您的配置，您或者需要在您的域之后命名文件，例如 ``mydomain.com.pem`` "
"并将其放在 Tigase XMPP 服务器安装的 ``certs/`` 子目录下，或者使用管理员 ad-"
"hoc 更新它（请参阅 :ref:`存储和管理证书<certificateStorage>`)"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:206
msgid ""
"If you moved all certs to a single directory, you may combine them using "
"the following command under \\*nix operating systems:."
msgstr "如果您将所有证书移动到单个目录，您可以在 \\*nix "
"操作系统下使用以下命令将它们组合起来："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:215
msgid ""
"If you are using ``isrgrootx1`` root make sure you use ``cert.pem`` file "
"instead of ``fullchain.pem``, which uses different intermediate "
"certificate ( `Let’s Encrypt Authority X3 (IdenTrust cross-signed) "
"<https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem.txt>`__ )"
" and you will have to use `DST Root CA X3 "
"<https://letsencrypt.org/certs/trustid-x3-root.pem.txt>`__ certificate!"
msgstr ""
"如果你使用的是 ``isrgrootx1`` 根确保你使用 ``cert.pem`` 文件而不是 "
"``fullchain.pem``，若使用不同的中间证书（`Let's Encrypt Authority X3 ("
"IdenTrust cross-signed) <https://letsencrypt.org/certs/lets-encrypt-x3-cross-"
"signed.pem.txt>`__ ），你将不得不使用 `DST Root CA X3 <https://letsencrypt."
"org/certs/trustid -x3-root.pem.txt>`__ 证书！"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:217
msgid "Your certificate should look something like this:"
msgstr "您的证书应如下所示："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:239
msgid ""
"LetsEncrypt certificates expire 90 days from issue and need to be renewed"
" in order for them to remain valid!"
msgstr "LetsEncrypt 证书在颁发后 90 天到期，需要更新才能保持有效！"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:241
msgid "You can check your certificate with utility class:"
msgstr "您可以使用实用程序类检查您的证书："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:248
msgid "Let’s encrypt and DNS verification"
msgstr "让我们加密和DNS验证"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:250
msgid ""
"The only way to obtain wildcard (``*.domain.com``) certificate is via DNS"
" verification. Certbot support a number of DNS operators - you can check "
"if your DNS provider is listed by executing ``$ certbot plugins``"
msgstr ""
"获得通配符（``*.domain.com``）证书的唯一方法是通过 DNS 验证。 Certbot "
"支持许多 DNS 运营商 - 您可以通过执行 ``$ certbot plugins`` 来检查您的 DNS "
"提供商是否在列表中"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:252
msgid "AWS Route53"
msgstr "AWS Route53"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:254
msgid "If you want to use it with Amazon Cloud you should install plugin for AWS:"
msgstr "如果您想将它与 Amazon Cloud 一起使用，您应该为 AWS 安装插件："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:262
msgid ""
"If you are using certbot under macOS and you installed it via brew then "
"you should use: ``$( brew --prefix certbot )/libexec/bin/pip install "
"certbot-dns-route53``"
msgstr ""
"如果您在 macOS 下使用 certbot 并通过 brew 安装它，那么您应该使用：``$( brew "
"--prefix certbot )/libexec/bin/pip install certbot-dns-route53``"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:264
msgid ""
"You should store your credentials in ``~/.aws/credentials`` (you may want"
" to create dedicated policy for updating DNS as described in `plugin’s "
"documentation <https://certbot-dns-route53.readthedocs.io/en/stable/>`__:"
msgstr ""
"您应该将您的凭据存储在 ``~/.aws/credentials`` 中（您可能希望创建用于更新 DNS "
"的专用策略，如 `plugin’s documentation <https://certbot-dns-route53."
"readthedocs.io/en/stable/>`__ 所描述:"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:272
msgid ""
"And afterward you should execute ``certbot`` with ``--dns-route53`` "
"parameter"
msgstr "之后你应该使用 ``--dns-route53`` 参数执行 ``certbot``"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:275
msgid "Certbot update hook and Tigase API"
msgstr "Certbot 更新钩子和 Tigase API"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:277
msgid ""
"For greater automation it’s possible to automate updating certificate "
"obtained with ``certbot`` in Tigase XMPP Server. You should use following"
" deploy hook - either add it to ``/etc/letsencrypt/renewal-"
"hooks/deploy/`` or use it directly in ``certboot`` commandline with "
"``--deploy-hook`` parameter (in the latter case, it will be added to "
"particular domain configuration so it’s not necessary to specify "
"UPDATE_DOMAINS)."
msgstr ""
"为了实现更高的自动化，可以自动更新通过 Tigase XMPP 服务器中的 ``certbot`` "
"获得的证书。您应该使用以下部署挂钩 - 或将其添加到 ``/etc/letsencrypt/"
"renewal-hooks/deploy/`` 或直接在带有 ``--deploy-hook`` 参数的 ``certboot`` "
"命令行中使用它（在后一种情况下，它将被添加到特定的域配置中，因此没有必要指定 "
"UPDATE_DOMAINS）。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:281
msgid ""
"Please adjust account credentials used for deployment (``USER``, "
"``PASS``, ``DOMAIN``) as well as paths to Let’s Encrypt certificates "
"(*ISRG Root X1* named ``isrgrootx1.pem`` and *Let’s Encrypt Authority X3*"
" named ``letsencryptauthorityx3.pem``)"
msgstr ""
"请调整用于部署的帐户凭据（``USER``, ``PASS``, ``DOMAIN``）以及 Let's Encrypt "
"证书的路径（*ISRG Root X1* 名为 ``isrgrootx1.pem`` 和 *Let’s Encrypt "
"Authority X3* 名为 ``letsencryptauthorityx3.pem``）"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:364
msgid ""
"If you are not using wildcard certificate when you have to provide "
"certificate for main domain as well as certificates for subdomains that "
"mach all components that you want to expose (muc, pubsub, push, etc…)"
msgstr "如果您没有使用通配符证书，则必须为主域提供证书以及为要公开的所有组件（muc, "
"pubsub, push 等）的子域提供证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:369
msgid "Storing and managing certificates"
msgstr "存储和管理证书"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:372
msgid "Filesystem"
msgstr "文件系统"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:374
msgid ""
"By default Tigase loads and stores certificates in ``certs/`` "
"subdirectory. Each *domain* certificate should be stored in a file which "
"filename consists of domain name and ``.pem`` extension, i.e. "
"``<domain>.pem``. For example for domain tigase.net it would be "
"``certs/tigase.net.pem``."
msgstr ""
"默认情况下，Tigase 在 ``certs/`` 子目录中加载和存储证书。每个 *domain* "
"证书都应该存储在一个文件中，此文件名由域名和 ``.pem`` 扩展名组成，即 "
"``<domain>.pem``。例如对于域 tigase.net，它将是 ``certs/tigase.net.pem``。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:378
msgid ""
"Tigase tries to be *smart* and automatically detects wildcard domain and "
"alternative domains so it’s not needed to duplicate same certificate in "
"multiple files to match domains."
msgstr "Tigase 尝试变得 *智能*，并自动检测通配符域和备用域，因此无需在多个文件中复制"
"相同的证书来匹配域。"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:381
msgid "Database repository"
msgstr "数据库存储库"

#: ../../Tigase_Administration/Security/Server_Certificates.inc:383
msgid ""
"Alternatively it’s possible to use database as a storage for the "
"certificates. Upon enabling it certificates won’t be read nor stored to "
"the filesystem. You can enable it by adding ``repository () {}`` bean to "
"``'certificate-container' () {}`` in your TDSL configuration file:"
msgstr ""
"或者，可以使用数据库作为证书的存储。启用它后，证书将不会被读取或存储到文件系"
"统中。您可以通过将 ``repository () {}`` bean 添加到 TDSL 配置文件中的 "
"``'certificate-container' () {}`` 来启用它："

#: ../../Tigase_Administration/Security/Server_Certificates.inc:391
msgid ""
"If you are using database repository then you manage/update certificates "
"using either ad-hoc command ``Add SSL certificate`` from *VHost Manager* "
"or via HTTP REST API."
msgstr ""
"如果您使用的是数据库存储库，那么您可以使用来自 *VHost Manager* 的临时命令 ``"
"Add SSL certificate`` 或通过 HTTP REST API 来管理/更新证书。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:4
msgid "Custom Authentication Connectors"
msgstr "自定义身份验证连接器"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:6
msgid ""
"This article presents configuration options available to the "
"administrator and describe how to set Tigase server up to use user "
"accounts data from a different database."
msgstr "本文介绍了管理员可用的配置选项，并描述了如何设置 Tigase "
"服务器以使用来自不同数据库的用户帐户数据。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:8
msgid ""
"The first thing to know is that Tigase server always opens 2 separate "
"connections to the database. One connection is used for user login data "
"and the other is for all other user data like the user roster, vCard, "
"private data storage, privacy lists and so on…​"
msgstr ""
"首先要知道的是 Tigase 服务器总是打开 2 个独立的数据库连接。一个连接用于用户登"
"录数据，另一个用于所有其他用户数据，如用户名册、vCard、私人数据存储、隐私列表"
"等……​"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:10
msgid ""
"In this article we still assume that Tigase server keeps user data in "
"it’s own database and only login data is retrieved from the external "
"database."
msgstr "在本文中，我们仍然假设 Tigase "
"服务器将用户数据保存在自己的数据库中，并且仅从外部数据库中检索登录数据。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:12
msgid "At the moment Tigase offers following authentication connectors:"
msgstr "目前 Tigase 提供以下身份验证连接器："

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:14
msgid ""
"``mysql``, ``pgsql``, ``derby`` - standard authentication connector used "
"to load user login data from the main user database used by the Tigase "
"server. In fact the same physical implementation is used for all JDBC "
"databases."
msgstr ""
"``mysql``, ``pgsql``, ``derby`` - 标准身份验证连接器，其用于从 Tigase "
"服务器使用的主用户数据库加载用户登录数据。实际上，所有 JDBC "
"数据库都使用相同的物理实现。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:16
msgid ""
"``drupal`` - is the authentication connector used to integrate the Tigase"
" server with `Drupal CMS <http://drupal.org/>`__."
msgstr ""
"``drupal`` - 是用于将 Tigase 服务器与 `Drupal CMS <http://drupal.org/>`__ "
"集成的身份验证连接器。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:18
msgid ""
"``tigase-custom`` - is the authentication connector which can be used "
"with any database. Unlike the 'tigase-auth' connector it allows you to "
"define SQL queries in the configuration file. The advantage of this "
"implementation is that you don’t have to touch your database. You can use"
" either simple plain SQL queries or stored procedures. The configuration "
"is more difficult as you have to enter carefully all SQL queries in the "
"config file and changing the query usually involves restarting the "
"server. For more details about this implementation and all configuration "
"parameters please refer to :ref:`Tigase Custom Auth "
"documentation<custonAuthConnector>`."
msgstr ""
"``tigase-custom`` - 是可用于任何数据库的身份验证连接器。与 'tigase-auth' "
"连接器不同，它允许您在配置文件中定义 SQL "
"查询。这种实现的优点是您不必接触数据库。您可以使用简单的普通 SQL "
"查询或存储过程。此时配置更加困难，因为您必须在配置文件中仔细输入所有 SQL 查询"
"，并且更改查询通常涉及重新启动服务器。有关此实现和所有配置参数的更多详细信息"
"，请参阅 :ref:`Tigase 自定义身份验证文档<custonAuthConnector>`。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:20
msgid ""
"|ss| ``tigase-auth``\\ |se|\\  (**DEPRECATED**) - is the authentication "
"connector which can be used with any database. It executes stored "
"procedures to perform all actions. Therefore it is a very convenient way "
"to integrate the server with an external database if you don’t want to "
"expose the database structure. You just have to provide a set of stored "
"procedures in the database. While implementing all stored procedures "
"expected by the server might be a bit of work it allows you to hide the "
"database structure and change the SP implementation at any time. You can "
"add more actions on user login/logout without restarting or touching the "
"server. And the configuration on the server side is very simple. For "
"detailed description of this implementation please refer to :ref:`Tigase "
"Auth documentation<tigaseAuthConnector>`."
msgstr ""
"|ss| ``tigase-auth``\\ |se|\\  (**DEPRECATED**) - 是可用于任何数据库的身份验"
"证连接器。它执行存储过程以执行所有操作。因此，如果您不想暴露数据库结构，将服"
"务器与外部数据库集成是一种非常方便的方法。您只需在数据库中提供一组存储过程。"
"虽然实现服务器预期的所有存储过程可能需要做一些工作，"
"但它允许您隐藏数据库结构并随时更改 SP 实现。您可以在用户登录/注销时添加更多操"
"作而无需重新启动或触摸服务器。并且服务器端的配置非常简单。有关此实现的详细说"
"明，请参阅 :ref:`Tigase Auth 文档<tigaseAuthConnector>`。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:22
msgid ""
"As always the simplest way to configure the server is through the "
"``config.tdsl`` file. In the article describing this file you can find "
"long list with all available options and all details how to handle it. "
"For the authentication connector setup however we only need 2 options:"
msgstr ""
"与往常一样，配置服务器的最简单方法是通过 ``config.tdsl`` 文件。在描述此文件的"
"文章中，您可以找到包含所有可用选项的长列表以及如何处理它的所有详细信息。但是"
"，对于身份验证连接器设置，我们只需要 2 个选项："

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:38
msgid ""
"For example if you store authentication data in a ``drupal`` database on "
"``localhost`` your settings would be:"
msgstr "例如，如果您将身份验证数据存储在 ``localhost`` 上的 ``drupal`` "
"数据库中，您的设置将是："

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:53
msgid ""
"You have to use a class name if you want to attach your own "
"authentication connector."
msgstr "如果要附加自己的身份验证连接器，则必须使用类名。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:55
msgid "Default is:"
msgstr "默认为："

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:65
msgid ""
"In the same exact way you can setup connector for any different database "
"type."
msgstr "以同样的方式，您可以为任何不同的数据库类型设置连接器。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:67
msgid "For example, drupal configuration is below"
msgstr "例如，drupal 配置如下"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:77
msgid "Or tigase-custom authentication connector."
msgstr "或 tigase-custom 身份验证连接器。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:87
msgid "The different ``cls`` or classes are:"
msgstr "不同的 ``cls`` 或类是:"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:89
#, fuzzy
msgid "Drupal - ``tigase.db.jdbc.DrupalWPAuth``"
msgstr "Drupal - ``tigase.db.jdbc.DrupalWPAuth``"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:91
#, fuzzy
msgid ""
"MySQL, Derby, PostgreSQL, MS SQL Server - "
"``tigase.db.jdbc.JDBCRepository``"
msgstr ""
"MySQL, Derby, PostgreSQL, MS SQL Server - ``tigase.db.jdbc.JDBCRepository``"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:93
msgid ""
"You can normally skip configuring connectors for the default Tigase "
"database format: ``mysql``, ``pgsql`` and ``derby``, ``sqlserver`` as "
"they are applied automatically if the parameter is missing."
msgstr ""
"您通常可以跳过默认 Tigase 数据库格式的配置连接器：``mysql``, ``pgsql`` 和 "
"``derby``, ``sqlserver`` ，因为如果缺少参数，它们会自动应用。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:95
msgid ""
"One more important thing to know is that you will have to modify "
"``authRepository`` if you use a custom authentication connector. This is "
"because if you retrieve user login data from the external database this "
"external database is usually managed by an external system. User accounts"
" are added without notifying Tigase server. Then, when the user logs in "
"and tries to retrieve the user roster, the server can not find such a "
"user in the roster database."
msgstr ""
"要知道的另一件重要的事情是，如果您使用自定义身份验证连接器，则必须修改 "
"``authRepository`` 。这是因为如果您从外部数据库检索用户登录数据，该外部数据库"
"通常由外部系统管理。用户帐户在不通知 Tigase 服务器的情况下被添加。然后，当用"
"户登录并尝试检索用户名册时，服务器在名册数据库中找不到这样的用户。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:99
msgid ""
"To keep user accounts in sync between the authentication database and the"
" main user database you have to add following option to the end of the "
"database connection URL: ``autoCreateUser=true``."
msgstr ""
"要使用户帐户在身份验证数据库和主用户数据库之间保持同步，您必须在数据库连接 "
"URL 的末尾添加以下选项：``autoCreateUser=true``。"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:101
#: ../../Tigase_Administration/Security/Packet_Filtering.inc:97
#, fuzzy
msgid "For example:"
msgstr "例如："

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:111
msgid ""
"If you are interested in even further customizing your authentication "
"connector by writing your own queries or stored procedures, please have a"
" look at the following guides:"
msgstr "如果您有兴趣通过编写自己的查询或存储过程来进一步自定义身份验证连接器，请查看"
"以下指南："

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:113
#, fuzzy
msgid ":ref:`Tigase Auth guide<tigaseAuthConnector>`"
msgstr ":ref:`Tigase Auth guide<tigaseAuthConnector>`"

#: ../../Tigase_Administration/Security/Auth_Connectors.inc:115
#, fuzzy
msgid ":ref:`Tigase Custom Auth guide<custonAuthConnector>`"
msgstr ":ref:`Tigase Custom Auth guide<custonAuthConnector>`"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:4
msgid "Tigase Auth Connector (DEPRECATED)"
msgstr "Tigase 身份验证连接器（已弃用）"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:10
msgid ""
"The Tigase Auth connector with shortcut name: **tigase-auth** is "
"implemented in the class: `tigase.db.jdbc.TigaseAuth "
"<https://github.com/tigase/tigase-"
"server/blob/master/src/main/java/tigase/db/jdbc/TigaseAuth.java>`__. It "
"allows you to connect to any external database to perform user "
"authentication. You can find more details how to setup a custom connector"
" in the :ref:`Custom Authentication Connectors<customAuthentication>` "
"guide."
msgstr ""
"快捷方式名为 **tigase-auth** 的 Tigase Auth 连接器在类中实现：`"
"tigase.db.jdbc.TigaseAuth <https://github.com/tigase/tigase-server/blob/"
"master/src/main/java/tigase/db/jdbc/TigaseAuth.java>`__ "
"。它允许您连接到任何外部数据库以执行用户身份验证。您可以在 :ref:`Custom "
"Authentication Connectors<customAuthentication>` "
"指南中找到如何设置自定义连接器的更多详细信息。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:12
msgid ""
"To make this connector working you have to prepare your database to offer"
" set of stored procedures for Tigase server to perform all the "
"authentication actions. The best description is the example schema with "
"all the stored procedures defined - please refer to the Tigase "
"repositories for the schema definition files (each component has it’s "
"dedicated schema). For example:"
msgstr ""
"要使此连接器正常工作，您必须准备数据库以提供一组存储过程供 Tigase "
"服务器执行所有身份验证操作。最好的描述是定义了所有存储过程的示例模式 - "
"请参阅 Tigase 存储库以获取模式定义文件（每个组件都有其专用的模式）。例如："

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:14
#, fuzzy
msgid ""
"`tigase-server <https://github.com/tigase/tigase-"
"server/tree/master/src/main/database>`__"
msgstr ""
"`tigase-server <https://github.com/tigase/tigase-server/tree/master/src/main/"
"database>`__"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:16
#, fuzzy
msgid ""
"`tigase-pubsub <https://github.com/tigase/tigase-"
"pubsub/tree/master/src/main/database>`__"
msgstr ""
"`tigase-pubsub <https://github.com/tigase/tigase-pubsub/tree/master/src/main/"
"database>`__"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:18
#, fuzzy
msgid ""
"`tigase-muc <https://github.com/tigase/tigase-"
"muc/tree/master/src/main/database>`__"
msgstr ""
"`tigase-muc <https://github.com/tigase/tigase-muc/tree/master/src/main/"
"database>`__"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:20
#, fuzzy
msgid ""
"`tigase-message-archiving <https://github.com/tigase/tigase-message-"
"archiving/tree/master/src/main/database>`__"
msgstr ""
"`tigase-message-archiving <https://github.com/tigase/"
"tigase-message-archiving/tree/master/src/main/database>`__"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:22
#, fuzzy
msgid ""
"`tigase-socks5 <https://github.com/tigase/tigase-"
"socks5/tree/master/src/main/database>`__"
msgstr ""
"`tigase-socks5 <https://github.com/tigase/tigase-socks5/tree/master/src/main/"
"database>`__"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:24
msgid "The absolute minimum of stored procedures you have to implement is:"
msgstr "您必须实现的存储过程的绝对最小值是："

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:26
msgid ""
"``TigUserLoginPlainPw`` - to perform user authentication. The procedure "
"is always called when the user tries to login to the XMPP server. This is"
" the only procedure which must be implemented and actually must work."
msgstr ""
"``TigUserLoginPlainPw`` - 执行用户身份验证。当用户尝试登录 XMPP "
"服务器时，总是会调用该程序。这是唯一必须实施并且必须切实可行的程序。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:28
msgid ""
"``TigUserLogout`` - to perform user logout. The procedure is always "
"called when the user logouts or disconnects from the server. This "
"procedure must be implemented but it can be empty and can do nothing. It "
"just needs to exist because Tigase expect it to exist and attempts to "
"call it."
msgstr ""
"``TigUserLogout`` - 执行用户注销。当用户注销或与服务器断开连接时，始终调用该"
"程序。这个程序必须执行，但它可以是空的并且什么也不做。它只需要存在，因为 "
"Tigase 期望它存在并尝试调用它。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:30
msgid ""
"With these 2 above stored procedures you can only perform user "
"login/logouts on the external database. You can’t register a user "
"account, change user password or remove the user. In many cases this is "
"fine as all the user management is handled by the external system."
msgstr ""
"使用上述 2 个存储程序，您只能在外部数据库上执行用户登录/注销。您不能注册用户"
"帐户，更改用户密码或删除用户。在许多情况下，这是可以的，因为所有用户管理都由"
"外部系统处理。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:32
msgid ""
"If you however want to allow for account management via XMPP you have to "
"implement also following procedures:"
msgstr "但是，如果您想允许通过 XMPP 进行帐户管理，您还必须执行以下程序："

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:34
msgid "``TigAddUserPlainPw`` - to add a new user account"
msgstr "``TigAddUserPlainPw`` - 添加新用户帐户"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:36
msgid "``TigRemoveUser`` - to remove existing user account"
msgstr "``TigRemoveUser`` - 删除现有用户帐户"

#: ../../Tigase_Administration/Security/Auth_Connectors/Tigase_Auth_Connector.inc:38
msgid ""
"``TigUpdatePasswordPlainPw`` - to change a user password for existing "
"account"
msgstr "``TigUpdatePasswordPlainPw`` - 更改现有帐户的用户密码"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:4
msgid "Tigase Custom Auth Connector"
msgstr "Tigase 自定义身份验证连接器"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:6
msgid ""
"The Tigase Custom Auth connector with shortcut name: **tigase-custom** is"
" implemented in the class: `tigase.db.jdbc.TigaseCustomAuth "
"<https://github.com/tigase/tigase-"
"server/tree/master/src/main/java/tigase/db/jdbc/TigaseCustomAuth.java>`__."
" It allows you to connect to any external database to perform user "
"authentication and use a custom queries for all actions."
msgstr ""
"具有快捷方式名称的 Tigase 自定义身份验证连接器：**tigase-custom** "
"在类中实现：`tigase.db.jdbc.TigaseCustomAuth <https://github.com/tigase/"
"tigase-server/tree/master/src /main/java/tigase/db/jdbc/TigaseCustomAuth.java"
">`__。它允许您连接到任何外部数据库来执行用户身份验证并对所有操作使用自定义查"
"询。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:8
msgid ""
"You can find more details how to setup a custom connector in the Custom "
"Authentication Connectors guide."
msgstr "您可以在自定义身份验证连接器指南中找到有关如何设置自定义连接器的更多详细信息"
"。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:10
msgid "The basic configuration is very simple:"
msgstr "基本配置非常简单："

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:21
msgid "That’s it."
msgstr "就这些"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:23
msgid ""
"The connector loads correctly and starts working using predefined, "
"default list of queries. In most cases you also might want to define your"
" own queries in the configuration file. The shortest possible description"
" is the following example of the content from the ``config.tdsl`` file:"
msgstr ""
"连接器正确加载并使用预定义的默认查询列表开始工作。在大多数情况下，您可能还想"
"在配置文件中定义自己的查询。最短的可能描述是来自 ``config.tdsl`` "
"文件中的以下内容示例："

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:25
msgid ""
"This query is used to check connection to the database, whether it is "
"still alive or not"
msgstr "此查询用于检查与数据库的连接是否还持活"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:35
msgid ""
"This is database initialization query, normally we do not use it, "
"especially in clustered environment"
msgstr "这是数据库初始化查询，一般我们不用，尤其是集群环境"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:47
#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:127
msgid ""
"``online_status`` column does not exist and would need to be added for "
"that query to work."
msgstr "``online_status`` 列不存在，需要添加该查询才能工作。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:49
msgid ""
"Below query performs user authentication on the database level. The "
"Tigase server does not need to know authentication algorithm or password "
"encoding type, it simply passes user id (BareJID) and password in form "
"which was received from the client, to the stored procedure. If the "
"authentication was successful the procedure returns user bare JID or null"
" otherwise. Tigase checks whether the JID returned from the query matches"
" JID passed as a parameter. If they match, the authentication is "
"successful."
msgstr ""
"下面的查询在数据库级别执行用户身份验证。 Tigase "
"服务器不需要知道身份验证算法或密码编码类型，它只需将从客户端接收到的用户 ID "
"(BareJID) 和密码传递给存储过程。如果身份验证成功，则该过程返回用户裸 JID，"
"否则返回 null。 Tigase 检查从查询返回的 JID 是否与作为参数传递的 JID "
"匹配。如果它们匹配，则认证成功。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:62
msgid ""
"``TigUserLoginPlainPw`` is no longer part of a Tigase XMPP Server "
"database schema and would need to be created."
msgstr "``TigUserLoginPlainPw`` 不再是 Tigase XMPP "
"服务器数据库模式的一部分，需要创建。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:64
msgid ""
"Below query returns number of user accounts in the database, this is "
"mainly used for the server metrics and monitoring components."
msgstr "下面的查询返回数据库中用户帐户的数量，这主要用于服务器指标和监控组件。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:74
msgid "The Below query is used to add a new user account to the database."
msgstr "下面的查询用于向数据库添加新的用户帐户。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:84
msgid ""
"Below query is used to remove existing account with all user’s data from "
"the database."
msgstr "下面的查询用于从数据库中删除包含所有用户数据的现有帐户。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:94
msgid ""
"This query is used for the user authentication if ``user-login-query`` is"
" not defined, that is if there is no database level user authentication "
"algorithm available. In such a case the Tigase server loads user’s "
"password from the database and compares it with data received from the "
"client."
msgstr ""
"如果未定义 ``user-login-query``，则此查询用于用户身份验证，即没有可用的数据库"
"级用户身份验证算法。在这种情况下，Tigase "
"服务器从数据库中加载用户密码，并将其与从客户端接收到的数据进行比较。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:104
msgid ""
"Below query is used for user password update in case user decides to "
"change his password."
msgstr "以下查询用于用户密码更新，以防用户决定更改密码。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:114
msgid ""
"This query is called on user logout event. Usually we use a stored "
"procedure which records user logout time and marks user as offline in the"
" database."
msgstr "此查询在用户注销时被调用。通常我们使用一个存储过程来记录用户注销时间并在数据"
"库中将用户标记为离线。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:129
msgid ""
"This configuration specifies what non-sasl authentication mechanisms to "
"expose to the client"
msgstr "此配置指定向客户端公开哪些非 SASL 身份验证机制"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:139
msgid ""
"This setting to specify what sasl authentication mechanisms expose to the"
" client"
msgstr "此设置指定向客户端公开哪些 sasl 身份验证机制"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:149
msgid ""
"Queries are defined in the configuration file and they can be either "
"plain SQL queries or stored procedures. If the query starts with "
"characters: ``{ call`` then the server assumes this is a stored procedure"
" call, otherwise it is executed as a plain SQL query. Each configuration "
"value is stripped from white characters on both ends before processing."
msgstr ""
"查询在配置文件中定义，它们可以是普通的 SQL 查询或存储过程。如果查询以字符 ``{"
" call`` 开头， 则服务器假定这是一个存储过程的调用，否则它作为普通 SQL "
"查询执行。在处理之前，每个配置值都从两端的白色字符中去除。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:151
msgid ""
"Please don’t use semicolon ``;`` at the end of the query as many JDBC "
"drivers get confused and the query may not work."
msgstr "请不要在查询末尾使用分号 ``;``，因为许多 JDBC "
"驱动程序会混淆，查询可能无法正常工作。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:153
msgid ""
"Some queries can take arguments. Arguments are marked by question marks "
"``?`` in the query. Refer to the configuration parameters description for"
" more details about what parameters are expected in each query."
msgstr "一些查询可以带参数。参数在查询中用问号 ``?`` "
"标记。有关每个查询中预期的参数的更多详细信息，请参阅配置参数说明。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:155
msgid ""
"This example shows how to use a stored procedure to add a user as a query"
" with 2 required parameters (username, and password)."
msgstr "此示例说明如何使用存储过程将用户添加为具有 2 "
"个必需参数（用户名和密码）的查询。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:165
msgid "The same query with plain SQL parameters instead:"
msgstr "使用普通 SQL 参数的相同查询："

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:171
msgid ""
"The order of the query arguments is important and must be exactly as "
"described in specification for each parameter."
msgstr "查询参数的顺序很重要，并且必须与每个参数的规范中描述的完全相同。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:174
msgid "Query Name"
msgstr "查询名称"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:174
msgid "Description"
msgstr "描述"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:174
msgid "Arguments"
msgstr "参数"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:174
msgid "Example Query"
msgstr "示例查询"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:176
#, fuzzy
msgid "``conn-valid-query``"
msgstr "``conn-valid-query``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:176
msgid "Query executed periodically to ensure active connection with the database."
msgstr "定期执行查询以确保与数据库保持连接。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:176
#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:178
msgid "Takes no arguments."
msgstr "不接受任何参数。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:176
#, fuzzy
msgid "``select 1``"
msgstr "``select 1``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:178
#, fuzzy
msgid "``init-db-query``"
msgstr "``init-db-query``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:178
msgid "Database initialization query which is run after the server is started."
msgstr "服务器启动后运行的数据库初始化查询。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:178
#, fuzzy
msgid "``update tig_users set online_status = 0``"
msgstr "``update tig_users set online_status = 0``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:180
#, fuzzy
msgid "``add-user-query``"
msgstr "``add-user-query``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:180
msgid "Query adding a new user to the database."
msgstr "向数据库添加新用户查询。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:180
#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:188
msgid "Takes 2 arguments: ``(user_id (JID), password)``"
msgstr "接受 2 个参数： ``(user_id (JID), password)``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:180
#, fuzzy
msgid "``insert into tig_users (user_id, user_pw) values (?, ?)``"
msgstr "``insert into tig_users (user_id, user_pw) values (?, ?)``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:182
#, fuzzy
msgid "``del-user-query``"
msgstr "``del-user-query``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:182
msgid "Removes a user from the database."
msgstr "从数据库中删除用户。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:182
#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:184
#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:190
msgid "Takes 1 argument: ``(user_id (JID))``"
msgstr "接受 1 个参数： ``(user_id (JID))``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:182
#, fuzzy
msgid "``delete from tig_users where user_id = ?``"
msgstr "``delete from tig_users where user_id = ?``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:184
#, fuzzy
msgid "``get-password-query``"
msgstr "``get-password-query``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:184
msgid "Retrieves user password from the database for given user_id (JID)."
msgstr "从数据库中找回给定 user_id (JID) 的用户密码。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:184
#, fuzzy
msgid "``select user_pw from tig_users where user_id = ?``"
msgstr "``select user_pw from tig_users where user_id = ?``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:186
#, fuzzy
msgid "``update-password-query``"
msgstr "``update-password-query``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:186
msgid "Updates (changes) password for a given user_id (JID)."
msgstr "更新（更改）给定 user_id (JID) 的密码。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:186
msgid "Takes 2 arguments: ``(password, user_id (JID))``"
msgstr "接受 2 个参数： ``(password, user_id (JID))``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:186
#, fuzzy
msgid "``update tig_users set user_pw = ? where user_id = ?``"
msgstr "``update tig_users set user_pw = ? where user_id = ?``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:188
#, fuzzy
msgid "``user-login-query``"
msgstr "``user-login-query``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:188
msgid ""
"Performs user login. Normally used when there is a special SP used for "
"this purpose. This is an alternative way to a method requiring retrieving"
" user password. Therefore at least one of those queries must be defined: "
"``user-login-query`` or ``get-password-query``. If both queries are "
"defined then ``user-login-query`` is used. Normally this method should be"
" only used with plain text password authentication or sasl-plain. Tigase "
"expects a result set with user_id to be returned from the query if login "
"is successful and empty results set if the login is unsuccessful."
msgstr ""
"执行用户登录。通常在有用于此目的的特殊 SP "
"时使用。这是需要找回用户密码的替代方法。因此，必须至少定义其中一个查询"
"：``user-login-query`` 或 ``get-password-query``。如果定义了两个查询，则使用 "
"``user-login-query``。通常，此方法应仅与纯文本密码身份验证或 sasl-plain "
"一起使用。如果登录成功，Tigase 期望从查询返回一个带有 user_id "
"的结果集，如果登录不成功，则返回空结果集。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:188
#, fuzzy
msgid "``select user_id from tig_users where (user_id = ?) AND (user_pw = ?)``"
msgstr "``select user_id from tig_users where (user_id = ?) AND (user_pw = ?)``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:190
#, fuzzy
msgid "``user-logout-query``"
msgstr "``user-logout-query``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:190
msgid ""
"This query is called when user logs out or disconnects. It can record "
"that event in the database."
msgstr "当用户注销或断开连接时调用此查询。它可以在数据库中记录该事件。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:190
#, fuzzy
msgid ""
"``update tig_users, set online_status = online_status - 1 where user_id ="
" ?``"
msgstr ""
"``update tig_users, set online_status = online_status - 1 where user_id = ?``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:192
#, fuzzy
msgid "``non-sasl-mechs``"
msgstr "``non-sasl-mechs``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:192
msgid ""
"Comma separated list of NON-SASL authentication mechanisms. Possible "
"mechanisms are: ``password`` and ``digest``. The digest mechanism can "
"work only with ``get-password-query`` active and only when password are "
"stored in plain text format in the database."
msgstr ""
"逗号分隔的非 SASL 身份验证机制列表。可能的机制是：``password`` 和 "
"``digest``。摘要机制只能在 ``get-password-query`` "
"激活且密码以纯文本格式存储在数据库中时起作用。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:194
#, fuzzy
msgid "``sasl-mechs``"
msgstr "``sasl-mechs``"

#: ../../Tigase_Administration/Security/Auth_Connectors/Custom_Auth_Connector.inc:194
msgid ""
"Comma separated list of SASL authentication mechanisms. Possible "
"mechanisms are all mechanisms supported by Java implementation. The most "
"common are: ``PLAIN``, ``DIGEST-MD5``, ``CRAM-MD5``. \"Non-PLAIN\" "
"mechanisms will work only with the ``get-password-query`` active and only"
" when passwords are stored in plain text format in the database."
msgstr ""
"逗号分隔的 SASL 身份验证机制列表。可能的机制都是 Java "
"实现支持的机制。最常见的是：``PLAIN``, ``DIGEST-MD5``, ``CRAM-MD5``。\"Non-"
"PLAIN\" 机制仅在 ``get-password-query`` "
"激活且密码以纯文本格式存储在数据库中时才有效。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Drupal_Auth.inc:2
msgid "Drupal Authentication"
msgstr "Drupal 身份验证"

#: ../../Tigase_Administration/Security/Auth_Connectors/Drupal_Auth.inc:4
msgid ""
"Currently, we can only check authentication against a **Drupal** database"
" at the moment. Full **Drupal** authentication is not implemented as of "
"yet."
msgstr "目前，我们目前只能针对 **Drupal** 数据库检查身份验证。完整的 **Drupal** "
"身份验证尚未被实现。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Drupal_Auth.inc:6
msgid ""
"As **Drupal** keeps encrypted passwords in database the only possible "
"authorization protocols are those based on PLAIN passwords."
msgstr "由于 **Drupal** 将加密密码保存在数据库中，唯一可能的授权协议是那些基于 PLAIN "
"密码的协议。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Drupal_Auth.inc:8
msgid ""
"To protect your passwords **Tigase** server must be used with SSL or TLS "
"encryption."
msgstr "为了保护您的密码 **Tigase** 服务器必须使用 SSL 或 TLS 加密。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Drupal_Auth.inc:10
msgid ""
"Implementation of a **Drupal** database based authorization is located in"
" ``tigase.db.jdbc.DrupalAuth`` class. Although this class is capable of "
"adding new users to the repository I recommend to switch in-band "
"registration off due to the caching problems in **Drupal.** Changes in "
"database are not synchronized with **Drupal** yet. Functionality for "
"adding new users is implemented only to ease user accounts migration from"
" different repository types from earlier **Tigase** server installations."
msgstr ""
"**Drupal** 基于数据库的授权的实现位于 ``tigase.db.jdbc.DrupalAuth`` "
"类中。尽管此类能够向存储库添加新用户，但由于 **Drupal** "
"中的缓存问题，我建议关闭带内注册。数据库中的更改尚未与 **Drupal** 同步。"
"添加新用户的功能仅用于简化从早期 **Tigase** "
"服务器安装的不同存储库类型迁移用户帐户。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Drupal_Auth.inc:12
msgid ""
"The purpose of that implementation was to allow all accounts "
"administration tasks from **Drupal** like: account creation, all accounts"
" settings, like e-mail, full name, password changes and so on."
msgstr "该实现的目的是允许来自 **Drupal** 的所有帐户管理任务，例如：帐户创建，所有帐"
"户设置，比如电子邮件，全名，密码更改等。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Drupal_Auth.inc:14
msgid ""
"**Tigase** server uses following fields from **Drupal** database: name "
"(user account name), pass (user account password), status (status of the "
"account). Server picks up all changes instantly. If user status is not 1 "
"then server won’t allow user to login trough XMPP even if user provides "
"valid password."
msgstr ""
"**Tigase** 服务器使用来自 **Drupal** 数据库的以下字段：name（用户帐户名），pa"
"ss（用户帐户密码），status（帐户状态）。服务器立即获取所有更改。"
"如果用户状态不是 1，那么即使用户提供了有效的密码，服务器也不会允许用户通过 "
"XMPP 登录。"

#: ../../Tigase_Administration/Security/Auth_Connectors/Drupal_Auth.inc:16
msgid ""
"There is no *Roster* management in **Drupal** yet. So Roster management "
"have to be done from the XMPP client."
msgstr "**Drupal** 中还没有 *Roster* 管理。所以名册管理必须从 XMPP 客户端完成。"

#: ../../Tigase_Administration/Security/Auth_Connectors/LDAP_Auth.inc:2
msgid "LDAP Authentication Connector"
msgstr "LDAP 身份验证连接器"

#: ../../Tigase_Administration/Security/Auth_Connectors/LDAP_Auth.inc:4
msgid ""
"Tigase XMPP Server offers support for authenticating users against an "
"LDAP server in **Bind** **Authentication** mode."
msgstr "Tigase XMPP 服务器支持在 **Bind** **Authentication** 模式下针对 LDAP "
"服务器对用户进行身份验证。"

#: ../../Tigase_Administration/Security/Auth_Connectors/LDAP_Auth.inc:6
msgid ""
"Configuration for the LDAP support is really simple you just have to add "
"a few lines to your ``config.tdsl`` file."
msgstr "LDAP 支持的配置非常简单，您只需在 ``config.tdsl`` 文件中添加几行即可。"

#: ../../Tigase_Administration/Security/Auth_Connectors/LDAP_Auth.inc:18
msgid ""
"Please note the ``USER_ID`` element, this is a special element of the "
"configuration which is used to authenticate particular user. Tigase LDAP "
"connector replaces it with appropriate data during authentication. You "
"can control what Tigase should put into this part. In your configuration "
"you must replace this string with one of the following:"
msgstr ""
"请注意 ``USER_ID`` 元素，这是用于验证特定用户配置的特殊元素。 Tigase LDAP "
"连接器在身份验证期间将其替换为适当的数据。您可以控制 Tigase "
"应该在这部分中添加什么内容。在您的配置中，您必须将此字符串替换为以下之一："

#: ../../Tigase_Administration/Security/Auth_Connectors/LDAP_Auth.inc:20
msgid "``%1$s`` - use user name only for authentication (JabberID’s localpart)"
msgstr "``%1$s`` - 仅使用用户名进行身份验证（JabberID 的本地部分）"

#: ../../Tigase_Administration/Security/Auth_Connectors/LDAP_Auth.inc:22
msgid ""
"``%2$s`` - use domain name only for authentication (JabberID’s domain "
"part)"
msgstr "``%2$s`` - 仅使用域名进行身份验证（JabberID 的域部分）"

#: ../../Tigase_Administration/Security/Auth_Connectors/LDAP_Auth.inc:24
msgid "``%3$s`` - use the whole Jabber ID (JID) for authentication"
msgstr "``%3$s`` - 使用整个 Jabber ID (JID) 进行身份验证"

#: ../../Tigase_Administration/Security/Auth_Connectors/LDAP_Auth.inc:28
msgid ""
"Please make sure that you included ``autoCreateUser=true`` in your main "
"data source (UserRepository and **not** above AuthRepository) as outlined"
" in `??? <#autoCreateUser>`__ - otherwise you may run into problems with "
"data access."
msgstr ""
"请确保您在主数据源（UserRepository 和 **不是** 以上 AuthRepository）中包含 "
"``autoCreateUser=true``，如 `[autoCreateUser] <#autoCreateUser>`__ - "
"否则您可能会遇到数据访问问题。"

#: ../../Tigase_Administration/Security/Auth_Connectors/SASL_EXTERNAL.inc:2
msgid "Configuration of SASL EXTERNAL"
msgstr "SASL 外部配置"

#: ../../Tigase_Administration/Security/Auth_Connectors/SASL_EXTERNAL.inc:4
msgid ""
"In order to enable SASL External set \"Client Certificate CA\" (``client-"
"trust-extension-ca-cert-path``) to the path containing Certification "
"Authority (CA) certificate in the VHost (domain) configuration, for "
"example ``/path/to/cacert.pem``"
msgstr ""
"为了启用 SASL 外部设置 \"Client Certificate CA\" (``client-trust-extension-"
"ca-cert-path``) 到包含 VHost（域）配置中的证书颁发机构 (CA) 证书的路径，例如 "
"``/path/to/cacert.pem``"

#: ../../Tigase_Administration/Security/Auth_Connectors/SASL_EXTERNAL.inc:6
msgid ""
"File ``cacert.pem`` contains Certificate Authority certificate which is "
"used to sign clients certificate."
msgstr "文件 ``cacert.pem`` 包含用于签署客户端证书的证书颁发机构证书。"

#: ../../Tigase_Administration/Security/Auth_Connectors/SASL_EXTERNAL.inc:8
msgid ""
"Client certificate must include user’s Jabber ID as ``XmppAddr`` in "
"``subjectAltName``:"
msgstr "客户端证书必须在 ``subjectAltName`` 中包含用户作为 ``XmppAddr`` 的 Jabber ID "
"："

#: ../../Tigase_Administration/Security/Auth_Connectors/SASL_EXTERNAL.inc:10
msgid ""
"As specified in RFC 3920 and updated in RFC 6120, during the stream "
"negotiation process an XMPP client can present a certificate (a “client "
"certificate”). If a JabberID is included in a client certificate, it is "
"encapsulated as an id-on-xmppAddr Object Identifier (“xmppAddr”), i.e., a"
" subjectAltName entry of type otherName with an ASN.1 Object Identifier "
"of “id-on-xmppAddr” as specified in Section 13.7.1.4 of RFC 6120, "
"`XEP-0178 <http://xmpp.org/extensions/xep-0178.html#c2s>`__."
msgstr ""
"正如 RFC 3920 中指定和在 RFC 6120 中更新的那样，在流协商过程中，XMPP "
"客户端可以提供证书（“client certificate”）。如果 JabberID "
"包含在客户端证书中，则将其封装为 id-on-xmppAddr 对象标识符（“xmppAddr”），即 "
"otherName 类型的 subjectAltName 条目，其 ASN.1 对象标识符为“id-on-xmppAddr”，"
"正如 RFC 6120 的第 13.7.1.4 节，`XEP-0178 <http://xmpp.org/extensions/"
"xep-0178.html#c2s>`__ 中所述。"

#: ../../Tigase_Administration/Security/Auth_Connectors/SASL_EXTERNAL.inc:12
msgid ""
"It is possible to make client certificate **required** using same VHost "
"configuration and enabling option ``Client Certificate Required`` "
"(``client-trust-extension-cert-required``)."
msgstr ""
"可以使制作客户端证书 **必需** 使用相同的 VHost 配置并启用选项 ``Client "
"Certificate Required`` (``client-trust-extension-cert-required``)。"

#: ../../Tigase_Administration/Security/Auth_Connectors/SASL_EXTERNAL.inc:14
msgid ""
"If this option will be enabled, then client **must provide** certificate."
" This certificate will be verified against ``clientCertCA``. If client "
"does not provide certificate or certificate will be invalid, **TLS "
"handshake will be interrupted and client will be disconnected**."
msgstr ""
"如果启用此选项，则客户端 **必须提供** 证书。该证书将根据 ``clientCertCA`` "
"进行验证。如果客户端不提供证书或证书无效，**TLS "
"握手将被中断并将客户端连接断开**。"

#: ../../Tigase_Administration/Security/Auth_Connectors/SASL_EXTERNAL.inc:16
msgid ""
"Using this options does not force client to use SASL EXTERNAL. Client "
"still may authenticate with other SASL mechanisms."
msgstr "使用此选项不会强制客户端使用 SASL EXTERNAL。客户端仍然可以使用其他 SASL "
"机制进行身份验证。"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:2
msgid "SASL Mechanisms"
msgstr "SASL 机制"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:4
msgid ""
"XMPP protocol supports many authentication methods, but most of them are "
"used as `SASL <https://tools.ietf.org/html/rfc4422>`__ mechanisms. Tigase"
" XMPP Server provides many SASL-based authentication mechanisms such as:"
msgstr ""
"XMPP 协议支持多种身份验证方式，但大多用作 `SASL <https://tools.ietf.org/html/"
"rfc4422>`__ 机制。 Tigase XMPP Server 提供了许多基于 SASL "
"的身份验证机制，例如："

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:6
msgid "PLAIN *(enabled)*"
msgstr "PLAIN *(启用)*"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:8
#, fuzzy
msgid "ANONYMOUS"
msgstr "ANONYMOUS"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:10
#, fuzzy
msgid "EXTERNAL"
msgstr "EXTERNAL"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:12
msgid "SCRAM-SHA-1 *(enabled)*"
msgstr "SCRAM-SHA-1 *(启用)*"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:14
msgid "SCRAM-SHA-256 *(enabled)*"
msgstr "SCRAM-SHA-256 *(启用)*"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:16
#, fuzzy
msgid "SCRAM-SHA-512"
msgstr "SCRAM-SHA-512"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:18
msgid ""
"Most of them are enabled by default on default Tigase XMPP Server "
"installation."
msgstr "它们中的大多数在默认的 Tigase XMPP 服务器安装中默认启用。"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:21
msgid "Enabling and disabling SASL mechanisms (credentials encoder/decoder)"
msgstr "启用和禁用 SASL 机制（凭证编码器/解码器）"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:23
msgid ""
"If you want to enable or disable one of password-based authentication "
"mechanism such as ``SCRAM-SHA-1``, ``SCRAM-SHA-256`` or ``SCRAM-SHA-512``"
" you can do that by enabling or disabling encoders and decoders used on "
"your installation. By enabling encoders/decoders you are deciding in what"
" form the password is stored in the database. Those changes may (and in "
"most cases will) impact which SASL mechanisms may be allowed to use on "
"your installation."
msgstr ""
"如果您想启用或禁用基于密码的身份验证机制之一，例如 ``SCRAM-SHA-1``, ``SCRAM-"
"SHA-256`` 或 ``SCRAM-SHA-512``，您可以通过启用或禁用安装中使用的编码器和解码"
"器。通过启用编码器/解码器，您可以决定密码以何种形式存储在数据库中。这些更改可"
"能（并且在大多数情况下）会影响哪些 SASL 机制允许在您的安装中使用。"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:27
msgid ""
"In most cases you should enable or disable both (credentials encoder and "
"decoder) of the same type at the same time. The only exception of this "
"rule is when you are changing those on already working installation. In "
"this case you should only enable encoder of the type which you want to "
"enable and request users to change their passwords. Then, after users "
"will change their passwords, you should reconfigure server to enable "
"decoder of the particular type. *(in other case user may loose a way to "
"log in to your installation as system will reject their credentials as it"
" may not have matching credentials for particular SASL mechanism)*."
msgstr ""
"在大多数情况下，您应该同时启用或禁用这两种相同类型（凭证编码器和解码器）。此"
"规则的唯一例外是当您更改那些已经工作的安装时。在这种情况下，您应该只启用您想"
"要启用的类型的编码器并要求用户更改他们的密码。在用户更改密码后，您应该重新配"
"置服务器以启用特定类型的解码器。 "
"*（在其他情况下，用户可能无法登录到您的安装，因为系统将拒绝他们的凭据，"
"因为它可能没有与特定 SASL 机制匹配的凭据）*。"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:30
msgid "**Enabling SCRAM-SHA-512 encoder**"
msgstr "**启用 SCRAM-SHA-512 编码器**"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:43
msgid "**Disabling SCRAM-SHA-1 decoder**"
msgstr "**禁用 SCRAM-SHA-1 解码器**"

#: ../../Tigase_Administration/Security/SASL_Mechanisms.inc:56
msgid ""
"It is strongly recommended not to disable encoders if you have enabled "
"decoder of the same type as it may lead to the authentication issues, if "
"client tries to use a mechanism which that is not available."
msgstr "如果您启用了相同类型的解码器，强烈建议不要禁用编码器，因为如果客户端尝试使用"
"不可用的机制，可能会导致身份验证问题。"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:2
msgid "Application passwords"
msgstr "应用程序密码"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:4
msgid ""
"In recent versions of Tigase XMPP Server it is possible to create and use"
" multiple username and password pairs to authorize connection to the "
"single XMPP account."
msgstr "在最新版本的 Tigase XMPP 服务器中，"
"可以创建和使用多个用户名和密码对来授权连接到单个 XMPP 帐户。"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:6
msgid ""
"With that in place it is now possible to have multiple password for a "
"multiple clients accessing the same account what can be used to increase "
"security of the account as even if one password compromised you can still"
" log in and block lost or compromised device."
msgstr ""
"有了这个，现在可以为访问同一帐户的多个客户端设置多个密码，这可用于提高帐户的"
"安全性，因为即使一个密码被泄露，您仍然可以登录并阻止丢失或受损的设备。"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:9
msgid "Adding application password"
msgstr "添加应用程序密码"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:11
msgid ""
"To add new username-password pair you need to execute ``Add user "
"credentials`` ad-hoc command (command node ``auth-credentials-add`` at "
"``sess-man``) while logged in the XMPP account for which you want to add "
"a new application password."
msgstr ""
"要添加新的用户名-密码对，您需要在登录XMPP 帐户并为其添加新应用程序密码时执行 "
"``Add user credentials`` 临时命令（ ``sess-man`` 的命令节点 ``auth-"
"credentials-delete``）。"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:13
#: ../../Tigase_Administration/Security/Application_Passwords.inc:41
msgid ""
"During execution for a command you will be provided with a form to fill "
"in with following fields:"
msgstr "在执行命令期间，您将获得一个表格，用于填写以下字段："

#: ../../Tigase_Administration/Security/Application_Passwords.inc:15
#: ../../Tigase_Administration/Security/Application_Passwords.inc:43
msgid "The Jabber ID for the account (``jid``) - bare JID of your account"
msgstr "帐户的 Jabber ID (``jid``) - 您帐户的裸 JID"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:17
msgid ""
"Credential ID (``credentialId``) - username for the new application "
"password"
msgstr "凭据 ID (``credentialId``) - 新应用程序密码的用户名"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:19
msgid "Password (``password``) - a new password"
msgstr "密码 (``password``) - 新密码"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:21
msgid "After submitting this form a new credential will be added."
msgstr "提交此表格后，将添加新的凭据。"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:24
msgid "Login in with application password"
msgstr "使用应用程序密码登录"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:26
msgid ""
"To log in with new password the XMPP client can use any SASL mechanism "
"but it needs to provide (in SASL message):"
msgstr "要使用新密码登录，XMPP 客户端可以使用任何 SASL 机制，但需要提供（在 SASL "
"消息中）："

#: ../../Tigase_Administration/Security/Application_Passwords.inc:28
msgid "``authzid`` - account JID"
msgstr "``authzid`` - 帐号 JID"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:30
msgid "``authcid`` - username for application password"
msgstr "``authcid`` - 应用程序密码的用户名"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:32
msgid "``passwd`` - application password"
msgstr "``passwd`` - 申请密码"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:34
msgid ""
"With proper values, you application will be able to log in using "
"application password."
msgstr "使用正确的值，您的应用程序将能够用应用程序密码登录。"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:37
msgid "Removing application password"
msgstr "删除应用程序密码"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:39
msgid ""
"If your device is compromised or lost and you want to remove application "
"password, you need to use a different device and log in on your XMPP "
"account. Then you need to execute ``Delete user credentials`` ad-hoc "
"command (command node ``auth-credentials-delete`` at ``sess-man``)."
msgstr ""
"如果您的设备被盗用或丢失并且您想删除应用程序密码，"
"您需要使用其他不同设备并登录您的 XMPP 帐户。然后你需要执行 ``Delete user "
"credentials`` 临时命令（``sess-man`` 的命令节点 ``auth-credentials-"
"delete``）。"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:45
msgid ""
"Credential ID (``credentialId``) - username for the application password "
"which you want to remove"
msgstr "凭据 ID (``credentialId``) - 要删除的应用程序密码的用户名"

#: ../../Tigase_Administration/Security/Application_Passwords.inc:47
msgid "After submitting this form a credential will be removed."
msgstr "提交此表格后，证书将被删除。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:2
msgid "Packet Filtering"
msgstr "包过滤"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:4
msgid ""
"Tigase offers different ways to filter XMPP packets flying through the "
"server. The most common use for packet filtering is to restrict users "
"from sending or receiving packets based on the sender or received "
"address."
msgstr "Tigase 提供了不同的方法来过滤通过服务器的 XMPP "
"数据包。包过滤最常见的用途是根据发送者或接收地址限制用户发送或接收数据包。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:6
msgid ""
"There are also different possible scenarios: time based filtering, "
"content filtering, volume filtering and so on."
msgstr "还有不同的可能场景：基于时间的过滤，内容过滤，音量过滤等。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:8
msgid "All pages in this section describe different filtering strategies."
msgstr "本节中的所有页面都描述了不同的过滤策略。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:11
msgid "Domain Based Packet Filtering"
msgstr "基于域的包过滤"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:13
msgid ""
"Domain based packet filtering is a simple filter allowing to restrict "
"user communication based on the source/destination domain name. This is "
"especially useful if we want to limit user communication within a single "
"- own domain only or a list of domains."
msgstr "基于域的数据包过滤是一个简单的过滤器，其允许根据源/目标域名限制用户通信。如果"
"我们希望仅在单个自己的域或域列表中限制用户通信，这将特别有用。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:15
msgid ""
"A company might not wish to allow employers to chat during work hours "
"with anybody in the world. A company may also have a few different "
"domains used by different branches or departments. An administrator may "
"restrict communication to a list of domains."
msgstr "公司可能不希望雇主在工作时间与世界上任何人聊天。一家公司也可能有几个不同的域"
"被不同的分支机构或部门使用。管理员可以将通信限制为域列表。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:18
msgid "Introduction"
msgstr "介绍"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:20
msgid ""
"The restriction is on a per-user basis. So the administrator can set a "
"different filtering rules for each user. There is also a per-domain "
"configuration and global-installation setting (applied from most general "
"to most specific, i.e. from installation to user)."
msgstr "限制是基于每个用户的。因此管理员可以为每个用户设置不同的过滤规则。还有一个按"
"域配置和全局安装设置（从最一般到最具体的应用，即从安装到用户）。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:22
msgid ""
"Regular users can not change the settings. So this is not like a privacy "
"list where the user control the filter. Domain filter can not be changed "
"or controlled by the user. The system administrator can change the "
"settings based on the company policy."
msgstr "普通用户无法更改设置。所以这不像用户控制过滤器的隐私列表。域过滤器不能由用户"
"更改或控制。系统管理员可以根据公司政策更改设置。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:24
msgid "There are predefined rules for packet filtering:"
msgstr "包过滤有预定义的规则："

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:26
msgid "``ALL`` - user can send and receive packets from anybody."
msgstr "``ALL`` - 用户可以发送和接收来自任何人的数据包。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:28
msgid ""
"``LOCAL`` - user can send and receive packets within the server "
"installation only and all it’s virtual domains."
msgstr "``LOCAL`` - 用户只能在服务器安装及其所有虚拟域内发送和接收数据包。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:30
msgid "``OWN`` - user can send and receive packets within his own domains only"
msgstr "``OWN`` - 用户只能在自己的域内发送和接收数据包"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:32
msgid ""
"``BLOCK`` - user can’t communicate with anyone. This could be used as a "
"means to temporarily disable account or domain."
msgstr "``BLOCK`` - 用户无法与任何人交流。这可以用作暂时禁用帐户或域的一种手段。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:34
msgid ""
"``LIST`` - user can send and receive packets within listed domains only "
"(i.e. *whitelist*)."
msgstr "``LIST`` - 用户只能在列出的域内发送和接收数据包（即 *白名单*）。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:36
msgid ""
"``BLACKLIST`` - user can communicate with everybody (like ``ALL``), "
"except contacts on listed domains."
msgstr "``BLACKLIST`` - 用户可以与所有人（如 ``ALL``）通信，除了列出域上的联系人。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:38
msgid "``CUSTOM`` - user can communicate only within custom created rules set."
msgstr "``CUSTOM`` - 用户只能在自定义创建的规则集中进行通信。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:40
msgid ""
"Whitelist (``LIST``) and blacklist (``BLACKLIST``) settings are mutually "
"exclusive, i.e. at any given point of time only one of them can be used."
msgstr "白名单 ( ``LIST``) 和黑名单 ( ``BLACKLIST``) "
"设置是互斥的，即在任何给定时间点，只能使用其中一个。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:42
msgid ""
"Those rules applicable to particular users are stored in the user "
"repository and are loaded for each user session. If there are no rules "
"stored for a particular user server tries to apply rules for a VHost of "
"particular user, and if there is no VHost filtering policy server uses "
"global server configuration. If there is no filtering policy altogether "
"server applies defaults based on following criteria:"
msgstr ""
"那些适用于特定用户的规则存储在用户存储库中，并为每个用户会话加载。如果没有为"
"特定用户存储规则，则服务器尝试为特定用户的 VHost 应用规则，并且如果没有 "
"VHost 过滤策略，服务器使用全局服务器配置。如果完全没有过滤策略，服务器将根据"
"以下条件应用默认值："

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:44
msgid "If this is **Anonymous** user then ``LOCAL`` rule is applied"
msgstr "如果这是 **Anonymous** 用户，则应用 ``LOCAL`` 规则"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:46
msgid "For all **other** users ``ALL`` rule is applied."
msgstr "对于所有 **other** 用户，应用 ``ALL`` 规则。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:51
msgid ""
"Filtering is performed by the domain filter plugin which must be loaded "
"at startup time. It is loaded by default if the plugins list is not set "
"in the configuration file. However if you have a list of loaded plugins "
"in the configuration file make sure ``domain-filter`` is on the list."
msgstr ""
"过滤由必须在启动时加载的域过滤器插件执行。如果配置文件中未设置插件列表，则默"
"认加载。但是，如果您在配置文件中有加载插件的列表，请确保 ``domain-filter`` "
"在列表中。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:53
msgid "There is no other configuration required for the plugin to work."
msgstr "该插件无需其他配置即可工作。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:56
msgid "Administration, Rules Management"
msgstr "行政，规则管理"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:58
msgid ""
"Although controlling domain filtering rules is possible for each user "
"separately, it is not practical for large installations. In most cases "
"users are stored in the database and a third-party system keeps all the "
"user information."
msgstr "尽管可以为每个用户单独控制域过滤规则，但对于大型安装来说并不实用。在大多数情"
"况下，用户存储在数据库中，第三方系统保存所有用户信息。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:60
msgid ""
"To change the rule for a single user you can use loadable administration "
"scripts feature and load `UserDomainFilter.groovy "
"<https://github.com/tigase/tigase-"
"server/tree/master/src/main/groovy/tigase/admin/UserDomainFilter.groovy>`__"
" script. It enables modifying rules for a given user JID."
msgstr ""
"要更改单个用户的规则，您可以使用可加载的管理脚本功能并加载 `"
"UserDomainFilter.groovy <https://github.com/tigase/tigase-server/tree/master/"
"src/main/groovy/tigase/admin/UserDomainFilter.groovy>`__ 脚本。"
"它可以修改给定用户 JID 的规则。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:63
msgid "Implementation"
msgstr "执行"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:65
msgid ""
"If you have a third party system which keeps and manages all user "
"information than you probably have your own UserRepository implementation"
" which allows the Tigase server to access user data. Filtering rules are "
"loaded from user repository using following command:"
msgstr ""
"如果您有一个保存和管理所有用户信息的第三方系统，那么您可能拥有自己的 "
"UserRepository 实现，它允许 Tigase "
"服务器访问用户数据。使用以下命令从用户存储库加载过滤规则："

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:72
msgid ""
"Where ``user_id`` is user Jabber ID without resource part, "
"``DomainFilter.ALLOWED_DOMAINS_KEY`` is a property key: ``allowed-"
"domains``. The user repository MUST return one of following only:"
msgstr ""
"其中 ``user_id`` 是没有资源部分的用户 Jabber ID，``DomainFilter."
"ALLOWED_DOMAINS_KEY`` 是属性键：``allowed-"
"domains``。用户存储库必须仅返回以下之一："

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:74
msgid "``ALL`` - if the user is allowed to communicate with anybody"
msgstr "``ALL`` - 如果允许用户与任何人通信"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:76
msgid ""
"``LOCAL`` - if the user is allowed to communicate with users on the same "
"server installation."
msgstr "``LOCAL`` - 如果允许用户与同一服务器安装上的用户进行通信。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:78
msgid ""
"``OWN`` - if the user is allowed to communicate with users within his own"
" domain only."
msgstr "``OWN`` - 如果只允许用户与他自己域内的用户进行通信。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:80
msgid ""
"``LIST`` - list of domains within which the user is allowed to "
"communicate with other users. No wild-cards are supported. User’s own "
"domain should be included too."
msgstr "``LIST`` - "
"允许用户与其他用户通信的域列表。不支持通配符。用户自己的域也应该包括在内。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:82
msgid ""
"``BLACKLIST`` - list of domains within which the user is NOT allowed to "
"communicate with other users. No wild-cards are supported. User’s own "
"domain should NOT be included."
msgstr "``BLACKLIST`` - "
"不允许用户与其他用户通信的域列表。不支持通配符。不应包含用户自己的域。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:84
msgid ""
"``CUSTOM`` - list of rules defining custom communication permissions "
"(server processes stanza according to first matched rule, similar to "
"XEP-0016) in the following format:"
msgstr "``CUSTOM`` - 定义自定义通信权限的规则列表（服务器根据第一个匹配的规则处理节，"
"类似于 XEP-0016），格式如下："

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:106
msgid "``null`` - a java null if there are no settings for the user."
msgstr "``null`` - 如果用户没有设置，则返回 java null。"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:108
msgid ""
"In case of ``LIST`` and ``BLACKLIST`` filtering options, it’s essential "
"to provide list of domains for the whitelisting/blacklisting. "
"``DomainFilter.ALLOWED_DOMAINS_LIST_KEY`` is a property key: \"allowed-"
"domains-list\". The user repository MUST return semicolon separated list "
"of domains: ``domain1.com;domain2.com,domain3.org``"
msgstr ""
"在 ``LIST`` 和 ``BLACKLIST`` "
"过滤选项的情况下，为白名单/黑名单提供域列表是必不可少的。 ``DomainFilter."
"ALLOWED_DOMAINS_LIST_KEY`` 是一个属性键：“allowed-domains-"
"list”。用户存储库必须返回分号分隔的域列表：``domain1.com;domain2.com,domain3."
"org``"

#: ../../Tigase_Administration/Security/Packet_Filtering.inc:110
msgid ""
"The filtering is performed by the ```tigase.xmpp.impl.DomainFilter`` "
"<https://github.com/tigase/tigase-"
"server/tree/master/src/main/java/tigase/xmpp/impl/DomainFilter.java>`__ "
"plugin. Please refer to source code for more implementation details."
msgstr ""
"过滤由 `tigase.xmpp.impl.DomainFilter <https://github.com/tigase/"
"tigase-server/tree/master/src/main/java/tigase/xmpp/impl/DomainFilter 执行."
"java>`__ 插件实现。更多实现细节请参考源代码。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:2
msgid "Access Control Lists in Tigase"
msgstr "Tigase 中的访问控制列表"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:4
msgid ""
"Tigase offers support for **Access Control List (ACL)** to allow for fine"
" grained access to administration commands on the server."
msgstr "Tigase 提供对 **访问控制列表 (ACL)** "
"的支持，以允许对服务器上的管理命令进行细粒度访问。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:6
msgid ""
"By default, all administration commands are only accessible (visible "
"through service discovery and can be executed) by the service "
"administrators. Service administrators are existing accounts with JIDs "
"(**BareJIDs**) listed in the ``config.tdsl`` file under ``admins = []`` "
"(please see :ref:`admins<admins>` for details)."
msgstr ""
"默认情况下，所有管理命令只能由服务管理员访问（通过服务发现可见并且可以执行）"
"。服务管理员是在 ``admins = []`` 下的 ``config.tdsl`` 文件中列出的具有 JID "
"(**BareJIDs**) 的现有帐户（有关详细信息，请参阅 :ref:`admins<admins>`）。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:8
msgid ""
"Additionally, other XMPP users and entities can be assigned permissions "
"to execute a command or commands using Tigase’s ACL capabilities."
msgstr "此外，可以为其他 XMPP 用户和实体分配权限以使用 Tigase 的 ACL "
"功能执行一个或多个命令。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:10
msgid ""
"The following is a list of possible ACL modifiers for administrator "
"command accessibility:"
msgstr "以下是管理员命令可访问的可能的 ACL 修饰符列表："

#: ../../Tigase_Administration/Security/Access_Control_List.inc:12
msgid ""
"``ALL`` - Everybody can execute the command, even users from different "
"federated servers."
msgstr "``ALL`` - 每个人都可以执行该命令，即使是来自不同联合服务器的用户。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:14
msgid ""
"``ADMIN`` - Local server administrators can execute the command, this is "
"a default setting if no ACL is set for a command."
msgstr "``ADMIN`` - 本地服务器管理员可以执行命令，如果没有为命令设置 "
"ACL，此为默认设置。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:16
msgid ""
"``LOCAL`` - All users with accounts on the local server can execute the "
"command. Users from other, federated servers will not be able to execute "
"the command."
msgstr "``LOCAL`` - 在本地服务器上拥有帐户的所有用户都可以执行该命令。来自其他联合服"
"务器的用户将无法执行该命令。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:18
msgid "``NONE`` - No one will be allowed to execute this command"
msgstr "``NONE`` - 不允许任何人执行此命令"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:20
msgid ""
"``DOMAIN_OWNER`` - Only user which is owner of the domain which items are"
" being manipulated is allowed to execute the comment. If script is not "
"checking permissions for the manipulated item, this value will behave in "
"the same way as ``LOCAL``."
msgstr ""
"``DOMAIN_OWNER`` - 只有作为正在操作项目的域的所有者的用户才被允许执行评论。如"
"果脚本没有检查被操作项的权限，则此值的行为方式与 ``LOCAL`` 相同。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:22
msgid ""
"``DOMAIN_ADMIN`` - Only user which is one of the domain administrators "
"will be able to execute the command manipulating items related to the "
"domain. If script is not checking permissions for the manipulated item, "
"this value will behave in the same way as ``LOCAL``."
msgstr ""
"``DOMAIN_ADMIN`` - 只有作为域管理员之一的用户才能执行操作与域相关的项目的命令"
"。如果脚本没有检查被操作项的权限，则此值的行为方式与 ``LOCAL`` 相同。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:24
msgid ""
"``example.com`` - Only users with accounts on the selected domain will be"
" able to execute the command. It may be useful to setup a domain "
"specifically for admin accounts, and automatically all users within that "
"domain would be able to run the command."
msgstr ""
"``example.com`` - 只有在所选域中拥有帐户的用户才能执行该命令。专门为管理员帐"
"户设置域可能很有用，并且该域中的所有用户都将能够自动运行该命令。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:26
msgid ""
"``user@example.com`` - Comma separated list of JIDs of users who can "
"execute the command."
msgstr "``user@example.com`` - 可以执行命令的用户的 JID 的逗号分隔列表。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:28
msgid ""
"In any case, regardless of ACL settings, any command can be executed and "
"accessed by the designated service wide administrators, that is accounts "
"listed as admins in the ``config.tdsl`` file."
msgstr ""
"在任何情况下，无论 ACL "
"设置如何，任何命令都可以由指定的服务范围管理员执行和访问，即在 ``config."
"tdsl`` 文件中列为管理员的帐户。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:30
msgid ""
"Multiple ACL modifiers can be combined and applied for any command. This "
"may not always makes sense. For example ALL supersedes all other "
"settings, so it does not make sense to combine it with any other "
"modifier. However, most others can be combined with JID to broaden access"
" to specific accounts."
msgstr ""
"多个 ACL 修饰符可以组合并应用于任何命令。这可能并不总是有意义的。例如 ALL "
"取代所有其他设置，因此将其与任何其他修饰符结合使用是没有意义的。但是，"
"大多数其他修饰符可以与 JID 结合以扩大对特定帐户的访问。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:32
msgid ""
"On Tigase server the Access Control List is checked for the first "
"matching modifier. Therefore if you combine ALL with any other modifier, "
"anybody from a local or remote service will always be able to execute the"
" command, no matter what other modifiers are added."
msgstr ""
"在 Tigase 服务器上，检查访问控制列表中的第一个匹配修饰符。因此，如果您将 ALL "
"与任何其他修饰符结合使用，则无论添加了哪些其他修饰符，本地或远程服务中的任何"
"人都将始终能够执行该命令。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:34
msgid ""
"Please note, the ACL lists work on the command framework level. Access is"
" verified before the command is actually executed. There might be "
"additional access restrictions within a command itself. In many cases, "
"even if all local users are permitted to execute a command (LOCAL "
"modifier), some commands allow only to be executed by a domain owner or a"
" domain administrator (and of course by the service-wide administrators "
"as well). All the commands related to a user management such as adding a "
"new user, removing a user, password changes, etc… belong to this "
"category. When conducting domain (vhost) management, "
"creation/registration of a new domain can be done by any local user (if "
"LOCAL ACL modifier is set) but then all subsequent domain management "
"tasks such as removing the vhost, updating its configuration, setting SSL"
" certificate can be done by the domain owner or administrator only."
msgstr ""
"请注意，ACL 列表在命令框架级别上工作。在实际执行命令之前验证访问。命令本身可"
"能存在其他访问限制。在许多情况下，即使允许所有本地用户执行命令（LOCAL 修饰符"
"），某些命令也只允许由域所有者或域管理员（当然也包括服务范围的管理员）执行。"
"所有与用户管理相关的命令，例如添加新用户，删除用户，更改密码等……都属于此类别"
"。进行域 (vhost) 管理时，任何本地用户都可以创建/注册新域（如果设置了 LOCAL "
"ACL 修饰符），但随后的所有域管理任务，例如删除 vhost、更新其配置、设置 SSL "
"证书只能由域所有者或管理员完成。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:36
msgid ""
"The ACL list is set for a specific Tigase component and a specific "
"command. Therefore the configuration property must specify all the "
"details. So the general format for configuring ACL for a command is this:"
msgstr "ACL 列表是为特定 Tigase 组件和特定命令设置的。因此配置属性必须指定所有细节。"
"所以为命令配置 ACL 的一般格式是这样的："

#: ../../Tigase_Administration/Security/Access_Control_List.inc:46
msgid "The breakdown is as such:"
msgstr "细分是这样的："

#: ../../Tigase_Administration/Security/Access_Control_List.inc:48
msgid ""
"``comp-id`` is the Tigase server component ID such as: sess-man, vhost-"
"man, c2s, etc.."
msgstr "``comp-id`` 是 Tigase 服务器组件 ID 如：sess-man、vhost-man、c2s 等。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:50
msgid ""
"``commands`` is a static text which indicates that the property is for "
"component’s command settings."
msgstr "``commands`` 是一个静态文本，以表示该属性用于组件的命令设置。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:52
msgid ""
"``command-id`` is a command ID for which we set the ACL such as query-"
"dns, http://jabber.org/protocol/admin#add-user, user-roster-management, "
"etc…"
msgstr ""
"``command-id`` 是我们为其设置 ACL 的命令 ID，例如 query-dns、http://jabber."
"org/protocol/admin#add-user、user-roster-management 等……"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:54
msgid "Here are a few examples:"
msgstr "这里有一些例子："

#: ../../Tigase_Administration/Security/Access_Control_List.inc:56
msgid "*Allowing local users to create and manage their own domains*"
msgstr "*允许本地用户创建和管理自己的域*"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:69
msgid ""
"In fact all the commands except item-add can be executed by the domain "
"owner or administrator."
msgstr "事实上，除了 item-add 之外的所有命令都可以由域所有者或管理员执行。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:71
msgid "*Allowing local users to execute user management commands:*"
msgstr "*允许本地用户执行用户管理命令：*"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:87
msgid ""
"As in the previous example, the commands will by executed only by local "
"users who are the specific domain administrators."
msgstr "与前面的示例一样，这些命令将仅由作为特定域管理员的本地用户执行。"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:89
msgid ""
"*Allowing users from a specific domain to execute query-dns command and "
"some other users for given JIDs from other domains:*"
msgstr "*允许来自特定域的用户执行 query-dns 以及来自其他域的给定 JID "
"的其他一些用户：*"

#: ../../Tigase_Administration/Security/Access_Control_List.inc:99
msgid ""
"To be able to set a correct ACL property you need to know component names"
" and command IDs. Component IDs can be found in the service discovery "
"information on running server or in the server logs during startup. A "
"command ID can be found in the command script source code. Each script "
"contains a list of metadata at the very beginning of it’s code. One of "
"them is ``AS:CommandId`` which is what you have to use for the ACL "
"setting."
msgstr ""
"为了能够设置正确的 ACL 属性，您需要知道组件名称和命令 ID。组件 ID "
"可以在正在运行的服务器上的服务发现信息或启动期间的服务器日志中找到。"
"可以在命令脚本源代码中找到命令 "
"ID。每个脚本在其代码的开头都包含一个元数据列表。其中之一是 ``AS:CommandId`` "
"，这是您必须用于 ACL 设置的内容。"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:2
msgid "TLS/SSL encryption features configuration"
msgstr "TLS/SSL 加密功能配置"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:4
msgid ""
"Tigase allows adjusting the most important parameters used when "
"establishing TLS connections - set of protocols and ciphers that will be "
"used during negotiation of the connection. The single most important is "
"``hardened-mode`` - it’s the most general configuration and offers three-"
"step adjustment of the settings - please see :ref:`hardened-"
"mode<hardenedMode>` for details. ``hardened-mode`` can be configured both"
" via TDSL configuration file (either on ``root`` level or for "
"``sslContextContainer`` for particular connection managers) or on VHost "
"level."
msgstr ""
"Tigase 允许调整在建立 TLS 连接时使用的最重要的参数 - "
"在连接协商期间将使用的一组协议和密码。最重要的一个是 ``hardened-mode`` - "
"它是最通用的配置，其提供了三步调整设置 - 详情请参阅 :ref:`hardened-"
"mode<hardenedMode>`。 ``hardened-mode`` 可以通过 TDSL 配置文件（在 ``root`` "
"级别或对于特定连接管理器的 ``sslContextContainer``）或 VHost 级别进行配置。"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:6
msgid ""
"If you want to disable certain protocols or ciphers you can use two "
"options: ``tls-disabled-protocols`` and ``tls-disabled-ciphers`` "
"respectively. They allow, as name suggests, disabling certain items from "
"default sets. They both takes an array of strings, which ten be removed "
"from the lists."
msgstr ""
"如果你想禁用某些协议或密码，你可以使用两个选项：分别是 ``tls-disabled-"
"protocols`` 和 ``tls-disabled-ciphers``。顾名思义，它们允许禁用默认集中的某些"
"项目。他们都接受一个字符串数组，从列表中删除哪十个。"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:8
msgid ""
"Let’s say you’d like to remove support for ``SSL``, ``SSLv2`` and "
"``SSLv3`` protocols. You should simply use following configuraiton: "
"``'tls-disabled-protocols' = ['SSL', 'SSLv2', 'SSLv3']``. Complete list "
"of protocols depends on particular Java version that you use - please "
"refer to the documentation for details. For example for the default "
"Java11 list you can check `SSLContext Algorithms "
"<https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-"
"names.html#sslcontext-algorithms>`__"
msgstr ""
"假设您想删除对 ``SSL``, ``SSLv2`` 和 ``SSLv3`` "
"协议的支持。您应该简单地使用以下配置：``'tls-disabled-protocols' = ['SSL', "
"'SSLv2', 'SSLv3']``。协议的完整列表取决于您使用的特定 Java 版本 - "
"请参阅文档了解详细信息。例如对于默认的 Java11 列表，您可以查看 `SSLContext "
"Algorithms <https://docs.oracle.com/en/java/javase/11/docs/specs/security/"
"standard-names.html#sslcontext-algorithms>`__"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:10
msgid ""
"``tls-disabled-ciphers`` follows same format and uses names defined in "
"`JSSE Cipher Suite Names "
"<https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-"
"names.html#jsse-cipher-suite-names>`__. It’s also possible to use regular"
" expressions to quickly eliminate groups of ciphers."
msgstr ""
"``tls-disabled-ciphers`` 遵循相同的格式并使用 `JSSE Cipher Suite Names "
"<https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names"
".html#jsse-cipher-suite-names>`__ "
"中定义的名称。也可以使用正则表达式来快速消除密码组。"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:12
msgid ""
"If you want to enable only specific protocols or ciphers irrespective of "
"``hardened-mode`` or above disabling options you can use ``tls-enabled-"
"protocols`` and ``tls-enabled-ciphers`` - those two options take arrays "
"as well and they will configure Tigase to use only those protocols or "
"ciphers that are provided (without support for regular expressions). "
"Therefore if you configure Tigase with ``'tls-enabled-protocols' = [ "
"'TLSv1.2' ]`` then **only** ``TLSv1.2`` will be supported by Tigase."
msgstr ""
"如果您只想启用特定的协议或密码，而不考虑 ``hardened-mode`` 或以上禁用选项，"
"您可以使用 ``tls-enabled-protocols`` 和 ``tls-enabled-ciphers`` - "
"这两个选项也接受数组，它们将会配置Tigase "
"以仅使用提供的那些协议或密码（不支持正则表达式）。因此，如果您使用 ``'tls-"
"enabled-protocols' = [ 'TLSv1.2' ]`` 配置 Tigase，那么 Tigase 将 **仅** 支持 "
"``TLSv1.2``。"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:14
msgid ""
"The last option that you may be interested in adjusting is ``ephemeral-"
"key-size`` - it follows Java’s configuration capabilities outlined in "
"`Customizing Size of Ephemeral Diffie-Hellman Keys "
"<https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-"
"extension-jsse-reference-guide.html#GUID-D9B216E8-3EFC-4882-B76E-"
"17A87D8F2F9D>`__. Tigase defaults Diffie-Hellman keys of 4096 bits."
msgstr ""
"您可能有兴趣调整的最后一个选项是 ``ephemeral-key-size`` - 它遵循 `"
"Customizing Size of Ephemeral Diffie-Hellman Keys <https://docs.oracle.com/"
"en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide."
"html#GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D>`__ 中概述的 Java 配置功能 。"
"Tigase 默认 Diffie-Hellman 密钥为 4096 位元。"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:18
msgid ""
"We try to provide the best default set of options therefore **it’s "
"recommendable to use defaults provided by Tigase**. If you want to make "
"your extremely secure (considering possible connectivity issues with "
"installations that may be less secure) then you should only adjust "
"``hardened-mode`` setting (and switch it to ``strict``)."
msgstr ""
"我们尝试提供最佳的默认选项集，因此 **建议使用 Tigase 提供的默认值**。如果你想"
"让你的系统非常安全（考虑到安装可能不太安全的连接问题），那么你应该只调整 "
"``hardened-mode`` 设置（并将其切换为 ``strict``）。"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:21
msgid "Testing hosts TLS capabilities"
msgstr "测试主机 TLS 功能"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:23
msgid ""
"If you run into issues with TLS connectivity it’s helpful to compare if "
"both installations support same set of protocols and ciphers. One of the "
"most versatile and helpful tools is `Mozilla’s CipherScan "
"<https://github.com/mozilla/cipherscan>`__. For example for our "
"installation ``tigase.im`` result would look like this:"
msgstr ""
"如果您遇到 TLS 连接问题，比较两个安装是否支持相同的协议和密码集会很有帮助。"
"最通用和最有用的工具之一是 `Mozilla’s CipherScan <https://github.com/mozilla/"
"cipherscan>`__。例如，对于我们的安装 ``tigase.im`` 结果将如下所示："

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:56
msgid "TLS 1.3 compatibility"
msgstr "TLS 1.3 兼容性"

#: ../../Tigase_Administration/Security/TLS_Features_Configuration.inc:58
msgid ""
"Due to compatibility issues, TLS 1.3 is currently (version 8.1.x) "
"disabled by default. It can be enabled by setting property ``tls-disable-"
"tls13`` of ``sslContextContainer`` bean to ``false``:"
msgstr ""
"由于兼容性问题，目前默认禁用 TLS 1.3（版本 8.1.x）。可以通过将 "
"``sslContextContainer`` bean 的属性 ``tls-disable-tls13`` 设置为 ``false`` "
"来启用它："

#~ msgid ""
#~ "Tigase allows adjusting the most "
#~ "important parameters used when establishing"
#~ " TLS connections - set of protocols"
#~ " and ciphers that will be used "
#~ "during negotiation of the connection. "
#~ "The single most important is "
#~ "``hardened-mode`` - it’s the most "
#~ "general configuration and offers three-"
#~ "step adjustment of the settings - "
#~ "please see `??? <#hardenedMode>`__ for "
#~ "details. ``hardened-mode`` can be "
#~ "configured both via TDSL configuration "
#~ "file (either on ``root`` level or "
#~ "for ``sslContextContainer`` for particular "
#~ "connection managers) or on VHost level."
#~ msgstr ""
